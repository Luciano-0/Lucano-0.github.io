<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>图的最短路径算法——Dijkstra和A*</title>
    <url>/2021/12/13/tech/DijkstraAndAStar/</url>
    <content><![CDATA[<ul>
<li><p><a href="/2021/12/11/tech/Graph/index.html">图的基本概念</a></p>
</li>
<li><p><a href="/2021/12/12/tech/GraphSearch/index.html">图的盲目搜索</a></p>
</li>
<li><p><a href="/2021/12/23/tech/SPFA/index.html">图的最短路径算法——SPFA</a></p>
</li>
</ul>
<h3 id="一、最短路径问题"><a href="#一、最短路径问题" class="headerlink" title="一、最短路径问题"></a>一、最短路径问题</h3><p>最短路径问题是一个基于开销的图搜索问题，指求解从图中的某一节点出发到达另一个节点经过所有边的开销和最小的路径。解决该问题的算法有：</p>
<ul>
<li>Dijkstra算法</li>
<li>A*算法</li>
<li>SPFA算法</li>
<li>Floyd算法</li>
</ul>
<span id="more"></span>
<h3 id="二、Dijkstra"><a href="#二、Dijkstra" class="headerlink" title="二、Dijkstra"></a>二、Dijkstra</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Dijkstra用于解决图的<strong>单源最短路径问题，其前提为路径开销都为正值</strong>，使用贪心的思想进行<strong>边放松</strong>，其最终的结果是生成一棵<strong>最短路径树</strong>。</p>
<ul>
<li><strong>边放松</strong>指的是在查找最短路径过程中，如果碰到一条边，通过该边到达某一结点的路径比之前记录的到达该点的路径短，那么这个更短的路径将会取代之前的路径。可以把路径理解成从起点到某一点连接了一条橡皮筋，从下图的A-&gt;B操作，橡皮筋就得到了放松。</li>
</ul>
<p><img data-src="/image/15-1.png" alt=" " style="zoom:100%;"/></p>
<ul>
<li><strong>最短路径树（Short Path Tree，SPT）</strong>是图的一颗子树，其中根节点到某一子节点的路径就是这两节点在图中的最短路径。</li>
</ul>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul>
<li>首先，我们需要一个数据结构用于储存各个节点搜索过程中产生的数据：其中包含是否已经找到最短路径的标志、从源节点到该节点当前路径的开销以及当前路径数组。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title">Distance</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> found;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> <span class="keyword">value</span> = <span class="built_in">float</span>.MaxValue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">List</span>&lt;<span class="title">Node</span>&lt;<span class="title">T</span>&gt;&gt; path</span> = <span class="keyword">new</span> List&lt;Node&lt;T&gt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dictionary&lt;Node&lt;T&gt;, Distance&gt; dis = <span class="keyword">new</span> Dictionary&lt;Node&lt;T&gt;, Distance&gt;();</span><br></pre></td></tr></table></figure>
<ul>
<li><p>一开始需要将字典初始化，将除了源节点O之外的所有节点开销设为无穷大，源节点则为0。</p>
</li>
<li><p><strong>接着进入循环，每次取未找到最短路径（found = false）且value最小的节点P，将found置为true，并遍历P的邻接节点，若遍历到的节点Q未找到最短路径，则检查通过P到达Q是否比Q原来的value小，若小则说明通过P到达Q为更优的路径，于是更新Q的value和path（这一步就是对O到Q的路径做了松弛），以此类推</strong>。</p>
<p>以上就是Dijkstra算法的关键部分，至于为什么每次要取value最小的节点P并且可以将P的found置为true，<strong>因为所有边的开销都为正值，而目前除了已找到最短路径的节点外，距离源节点O最近的是P，那么就不可能通过其他未知的路径，进一步缩短从源节点到达P的开销。</strong>这一步就是Dijkstra算法贪心思想的体现。</p>
</li>
<li><p>若没有输入目标节点，则算法可以找到从源节点到任一节点的最短路径，形成最短路径树；若输入了目标节点，则循环可以在目标节点的最短路径找到后返回。</p>
</li>
</ul>
<h4 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h4><ul>
<li>以下图为例，假设源节点为0。</li>
</ul>
<p><img data-src="/image/15-2.png" alt=" " style="zoom:100%;"/></p>
<ul>
<li>首先将字典初始化为：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">dis</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">value</td>
<td style="text-align:center">0</td>
<td style="text-align:center">∞</td>
<td style="text-align:center">∞</td>
<td style="text-align:center">∞</td>
<td style="text-align:center">∞</td>
<td style="text-align:center">∞</td>
<td style="text-align:center">∞</td>
</tr>
<tr>
<td style="text-align:center">found</td>
<td style="text-align:center">false</td>
<td style="text-align:center">false</td>
<td style="text-align:center">false</td>
<td style="text-align:center">false</td>
<td style="text-align:center">false</td>
<td style="text-align:center">false</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center">path</td>
<td style="text-align:center">null</td>
<td style="text-align:center">null</td>
<td style="text-align:center">null</td>
<td style="text-align:center">null</td>
<td style="text-align:center">null</td>
<td style="text-align:center">null</td>
<td style="text-align:center">null</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>第一次循环：取0节点，0-&gt;0的最短路径找到，更新0节点的found和path，然后遍历可从0节点到达的节点：5、6，更新他们的value和path。</li>
</ul>
<p><img data-src="/image/15-3.png" alt=" " style="zoom:100%;"/></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">dis</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">value</td>
<td style="text-align:center">0</td>
<td style="text-align:center">∞</td>
<td style="text-align:center">∞</td>
<td style="text-align:center">∞</td>
<td style="text-align:center">∞</td>
<td style="text-align:center"><strong>3</strong></td>
<td style="text-align:center"><strong>5</strong></td>
</tr>
<tr>
<td style="text-align:center">found</td>
<td style="text-align:center"><strong>true</strong></td>
<td style="text-align:center">false</td>
<td style="text-align:center">false</td>
<td style="text-align:center">false</td>
<td style="text-align:center">false</td>
<td style="text-align:center">false</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center">path</td>
<td style="text-align:center"><strong>0-&gt;0</strong></td>
<td style="text-align:center">null</td>
<td style="text-align:center">null</td>
<td style="text-align:center">null</td>
<td style="text-align:center">null</td>
<td style="text-align:center"><strong>0-&gt;5</strong></td>
<td style="text-align:center"><strong>0-&gt;6</strong></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>第二次循环：取未找到最短路径节点中value最小的节点：5，0-&gt;5最短路径已找到，因为不可能通过其他节点，进一步缩短0-&gt;5的距离了，因此更新5节点的found和path，并遍历从5节点能到达的节点：6、4，发现0-&gt;5-&gt;6的路径优于0-&gt;6的路径，因此更新4和6节点的value和path。</li>
</ul>
<p><img data-src="/image/15-4.png" alt=" " style="zoom:100%;"/></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">dis</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">value</td>
<td style="text-align:center">0</td>
<td style="text-align:center">∞</td>
<td style="text-align:center">∞</td>
<td style="text-align:center">∞</td>
<td style="text-align:center">8</td>
<td style="text-align:center">3</td>
<td style="text-align:center"><strong>4</strong></td>
</tr>
<tr>
<td style="text-align:center">found</td>
<td style="text-align:center">true</td>
<td style="text-align:center">false</td>
<td style="text-align:center">false</td>
<td style="text-align:center">false</td>
<td style="text-align:center">false</td>
<td style="text-align:center"><strong>true</strong></td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center">path</td>
<td style="text-align:center">0-&gt;0</td>
<td style="text-align:center">null</td>
<td style="text-align:center">null</td>
<td style="text-align:center">null</td>
<td style="text-align:center"><strong>0-&gt;5-&gt;4</strong></td>
<td style="text-align:center">0-&gt;5</td>
<td style="text-align:center"><strong>0-&gt;5-&gt;6</strong></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>以此类推…</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">dis</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">value</td>
<td style="text-align:center">0</td>
<td style="text-align:center">5</td>
<td style="text-align:center">9</td>
<td style="text-align:center">7</td>
<td style="text-align:center">8</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">found</td>
<td style="text-align:center">true</td>
<td style="text-align:center">true</td>
<td style="text-align:center">true</td>
<td style="text-align:center">true</td>
<td style="text-align:center">true</td>
<td style="text-align:center">true</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td style="text-align:center">path</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0-&gt;5-&gt;6-&gt;1</td>
<td style="text-align:center">0-&gt;5-&gt;6-&gt;1-&gt;2</td>
<td style="text-align:center">0-&gt;5-&gt;6-&gt;3</td>
<td style="text-align:center">0-&gt;5-&gt;4</td>
<td style="text-align:center">0-&gt;5</td>
<td style="text-align:center">0-&gt;5-&gt;6</td>
</tr>
</tbody>
</table>
</div>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Dijkstra</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title">Distance</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">bool</span> found;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">float</span> <span class="keyword">value</span> = <span class="built_in">float</span>.MaxValue;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">List</span>&lt;<span class="title">Node</span>&lt;<span class="title">T</span>&gt;&gt; path</span> = <span class="keyword">new</span> List&lt;Node&lt;T&gt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Node&lt;T&gt;&gt; DijkstraSearch(Graph&lt;T&gt; graph, Node&lt;T&gt; start, Node&lt;T&gt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (graph == <span class="literal">null</span> || start == <span class="literal">null</span> || !graph.IsNode(start)) <span class="keyword">return</span> <span class="keyword">new</span> List&lt;Node&lt;T&gt;&gt;();</span><br><span class="line">        Dictionary&lt;Node&lt;T&gt;, Distance&gt; dis = <span class="keyword">new</span> Dictionary&lt;Node&lt;T&gt;, Distance&gt;();</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> vn <span class="keyword">in</span> graph)</span><br><span class="line">        &#123;</span><br><span class="line">            dis[vn.Data] = <span class="keyword">new</span> Distance();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dis[start].<span class="keyword">value</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!dis[end].found)</span><br><span class="line">        &#123;</span><br><span class="line">            Node&lt;T&gt; minNode = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">float</span> temp = <span class="built_in">float</span>.MaxValue;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> kv <span class="keyword">in</span> dis)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (kv.Value.<span class="keyword">value</span> &lt; temp &amp;&amp; kv.Value.found == <span class="literal">false</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    minNode = kv.Key;</span><br><span class="line">                    temp = kv.Value.<span class="keyword">value</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (minNode == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">            dis[minNode].found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">var</span> adjNode = graph[minNode].FirstAdjNode;</span><br><span class="line">            <span class="keyword">while</span> (adjNode != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> d = dis[adjNode.Data];</span><br><span class="line">                <span class="keyword">if</span> (d.found == <span class="literal">false</span> &amp;&amp; adjNode.Cost + dis[minNode].<span class="keyword">value</span> &lt; d.<span class="keyword">value</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    d.<span class="keyword">value</span> = adjNode.Cost + dis[minNode].<span class="keyword">value</span>;</span><br><span class="line">                    d.path = <span class="keyword">new</span> List&lt;Node&lt;T&gt;&gt;(dis[minNode].path) &#123;minNode&#125;;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                adjNode = adjNode.Next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dis[end].path.Count &gt; <span class="number">0</span>) dis[end].path.Add(end);</span><br><span class="line">        <span class="keyword">return</span> dis[end].path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>未经过优化的Dijkstra算法时间复杂度为O(n^2)，而每次选最小节点的步骤可以使用堆进行优化，可以考虑使用二叉堆、二项堆或者斐波那契堆，优化后的时间复杂度计算可以参考：<a href="https://blog.csdn.net/michealoven/article/details/114040136">Dijkstra算法时间复杂度分析</a></p>
<h3 id="三、A"><a href="#三、A" class="headerlink" title="三、A*"></a>三、A*</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>Dijkstra算法在搜索过程中还是需要检查太多的边，在找到目标节点之前，算法会在各个方向上进行尝试。而A<em>算法就是在Dijkstra算法的基础上引入了<em>*启发函数</em></em>的概念，大大地提高了搜索的效率。</p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul>
<li><p><strong>启发函数指的是对当前节点到目标节点开销的估计值，如果算法使用的启发函数是从任何节点到目标节点的实际开销的下限（低估开销得到），那么A*算法可以保证给出最优路径。</strong>如对于导航图最常用的启发函数就是节点之间的直线距离。</p>
</li>
<li><p>A*算法的工作方式和Dijkstra几乎一致，唯一的区别就是每个节点开销F的计算变成了:</p>
<script type="math/tex; mode=display">
F=G+H</script><p>G为到达一个节点的累计开销，H是一个启发函数。</p>
</li>
</ul>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">AStar</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title">Distance</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">bool</span> found;</span><br><span class="line">        <span class="comment">// F = G + H</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">float</span> f = <span class="built_in">float</span>.MaxValue;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">float</span> g = <span class="built_in">float</span>.MaxValue;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">List</span>&lt;<span class="title">Node</span>&lt;<span class="title">T</span>&gt;&gt; path</span> = <span class="keyword">new</span> List&lt;Node&lt;T&gt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Node&lt;T&gt;&gt; AStarSearch(Graph&lt;T&gt; graph, Node&lt;T&gt; start, Node&lt;T&gt; end,</span><br><span class="line">        Func&lt;Node&lt;T&gt;, Node&lt;T&gt;, <span class="built_in">float</span>&gt; heuristic)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (graph == <span class="literal">null</span> || start == <span class="literal">null</span> || !graph.IsNode(start)) <span class="keyword">return</span> <span class="keyword">new</span> List&lt;Node&lt;T&gt;&gt;();</span><br><span class="line">        Dictionary&lt;Node&lt;T&gt;, Distance&gt; dis = <span class="keyword">new</span> Dictionary&lt;Node&lt;T&gt;, Distance&gt;();</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> vn <span class="keyword">in</span> graph)</span><br><span class="line">        &#123;</span><br><span class="line">            dis[vn.Data] = <span class="keyword">new</span> Distance();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dis[start].f = <span class="number">0</span>;</span><br><span class="line">        dis[start].g = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!dis[end].found)</span><br><span class="line">        &#123;</span><br><span class="line">            Node&lt;T&gt; minNode = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">float</span> temp = <span class="built_in">float</span>.MaxValue;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> kv <span class="keyword">in</span> dis)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (kv.Value.f &lt; temp &amp;&amp; kv.Value.found == <span class="literal">false</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    minNode = kv.Key;</span><br><span class="line">                    temp = kv.Value.f;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (minNode == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">            dis[minNode].found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">var</span> adjNode = graph[minNode].FirstAdjNode;</span><br><span class="line">            <span class="keyword">while</span> (adjNode != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> d = dis[adjNode.Data];</span><br><span class="line">                <span class="keyword">if</span> (d.found)</span><br><span class="line">                &#123;</span><br><span class="line">                    adjNode = adjNode.Next;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (adjNode.Cost + dis[minNode].g &lt; d.g)</span><br><span class="line">                &#123;</span><br><span class="line">                    d.g = adjNode.Cost + dis[minNode].g;</span><br><span class="line">                    d.f = d.g + heuristic(adjNode.Data, end);</span><br><span class="line">                    d.path = <span class="keyword">new</span> List&lt;Node&lt;T&gt;&gt;(dis[minNode].path) &#123;minNode&#125;;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                adjNode = adjNode.Next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dis[end].path.Count &gt; <span class="number">0</span>) dis[end].path.Add(end);</span><br><span class="line">        <span class="keyword">return</span> dis[end].path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h4><h5 id="结合Floyd算法"><a href="#结合Floyd算法" class="headerlink" title="结合Floyd算法"></a>结合Floyd算法</h5><p>Floyd算法是预计算每一条可能的路径存在查找表中，这是实时寻路最快的一种算法（比A*快一个数量级），但其对空间的需求非常大。不过我们有办法通过压缩减少其对空间的需求，达到可接受的水平。</p>
<p><img data-src="/image/15-5.png" alt=" " style="zoom:100%;"/></p>
<ul>
<li><p><strong>无损压缩：只存储关键的”换乘点“信息</strong></p>
<p>在实际应用的寻路地图中，最佳路径的数量是有限的，而且多数重叠，因此我们可以找到最佳路径会经过的有限的”换乘点“，每个节点保存通往该节点所有换乘点的路径以及换乘点之间的最佳路径。</p>
</li>
<li><p><strong>有损压缩：欧几里得嵌入算法</strong></p>
<p>我们可以只储存查找表中的一部分行和列，这些数据可以成为<strong>枢纽节点</strong>来优化A*算法的启发函数，使得启发函数对距离的估算更加准确。</p>
</li>
</ul>
<h5 id="使用最恰当的搜索空间表征"><a href="#使用最恰当的搜索空间表征" class="headerlink" title="使用最恰当的搜索空间表征"></a>使用最恰当的搜索空间表征</h5><ul>
<li>常见的三种空间表征有：网格图、路点图、导航网格</li>
</ul>
<p><img data-src="/image/15-6.png" alt=" " style="zoom:100%;"/></p>
<ul>
<li>在大世界的地图中，以上三种空间表征可能性能开销都非常大，这时候就需要进行<strong>分层寻路</strong>。将较高的层级抽象为”区域到区域“的寻路方式，而较低的层级则抽象为”节点到节点“的寻路方式。</li>
</ul>
<h5 id="高估启发函数"><a href="#高估启发函数" class="headerlink" title="高估启发函数"></a>高估启发函数</h5><p>低估启发函数可以保证找到最优路径，但有时可以适当高估启发函数，得到一条不那么优的路径，但是可以大幅度提高寻路性能。可以使用加权的启发函数：</p>
<script type="math/tex; mode=display">
f(x) = g(x) + h(x) * w(x)</script><p>其中<em>w(x)</em>可以位置变化而变化，如：当距离目标较远时，<em>w(x)</em>取较大值，牺牲一定的精确度，快速接近目标；当距离目标较小时，<em>w(x)</em>取较小值，精确地到达目标位置。</p>
<h5 id="更好的启发函数"><a href="#更好的启发函数" class="headerlink" title="更好的启发函数"></a>更好的启发函数</h5><p>以网格图为例，可以选用三种启发函数：欧几里得距离（直线距离）、对角线距离和曼哈顿距离，曼哈顿距离不考虑对角线行走，总是高估距离，欧几里得距离总是低估距离，而对角线距离是最合适的启发函数：</p>
<script type="math/tex; mode=display">
max(\Delta x, \Delta y) + 0.41*min(\Delta x,\Delta y)</script><h5 id="开表的选择"><a href="#开表的选择" class="headerlink" title="开表的选择"></a>开表的选择</h5><p>通常情况下会选用堆来维护开表，但在节点数量较少时，采用简单的数组，插入开销小，查找需要遍历，但整体上对缓存友好，维护数据结构的开销几乎为0，因此寻路速度反而更快。</p>
<h5 id="寻路期间请勿回溯"><a href="#寻路期间请勿回溯" class="headerlink" title="寻路期间请勿回溯"></a>寻路期间请勿回溯</h5><p>在网格图中存在许多短循环，而我们在寻路过程中不需要考虑那些与父节点临近的点，排除这些点可以避免许多多余的查找。这也是跳点寻路算法的思想：<a href="https://zhuanlan.zhihu.com/p/181734749">Jump Point Search(JPS)算法总结与实现</a></p>
<p><strong>参考资料：</strong></p>
<ul>
<li>《人工智能编程案例精粹》第5章：图的秘密生命</li>
<li>《游戏人工智能》17：寻路架构的优化</li>
<li><a href="https://blog.csdn.net/qq_35644234/article/details/60870719">最短路径问题—-Dijkstra算法详解</a></li>
<li><a href="https://blog.csdn.net/michealoven/article/details/114040136">Dijkstra算法时间复杂度分析</a></li>
</ul>
<p><strong>Demo地址：</strong><a href="https://github.com/Luciano-0/Graph.git">https://github.com/Luciano-0/Graph.git</a></p>
]]></content>
      <tags>
        <tag>Graph</tag>
        <tag>AI</tag>
        <tag>寻路</tag>
      </tags>
  </entry>
  <entry>
    <title>DoTween</title>
    <url>/2020/09/15/tech/DoTween/</url>
    <content><![CDATA[<h1 id="1-Introdution"><a href="#1-Introdution" class="headerlink" title="1. Introdution"></a>1. Introdution</h1><span id="more"></span>
<h1 id="2-Function"><a href="#2-Function" class="headerlink" title="2. Function"></a>2. Function</h1><h2 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a><strong>Transform</strong></h2><p><code>transform.Func()</code></p>
<h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><ul>
<li><code>DOMove(Vector3 target, float time)</code></li>
<li><code>DOLocalMove()</code></li>
<li><code>DOPunchPosition()</code></li>
</ul>
<h3 id="rotation"><a href="#rotation" class="headerlink" title="rotation"></a>rotation</h3><ul>
<li><code>DORotate()</code></li>
<li><code>DOLocalRotate()</code></li>
<li><code>DORotateQuaternion()</code></li>
<li><code>DOLookat()</code></li>
<li><code>DOPunchRotation()</code></li>
</ul>
<h3 id="scale"><a href="#scale" class="headerlink" title="scale"></a>scale</h3><ul>
<li><code>DOScale()</code></li>
<li><code>DOPunchScale()</code></li>
</ul>
<h3 id="other"><a href="#other" class="headerlink" title="other"></a>other</h3><ul>
<li><code>DOShakePosition()</code>：常用于相机的振动效果</li>
</ul>
<h3 id="blend"><a href="#blend" class="headerlink" title="blend"></a>blend</h3><ul>
<li>如果同时执行两个<code>DOMove()</code>，则前一个会被覆盖，这时需要使用动画混合</li>
<li>实现增量控制</li>
<li><code>DOBlendableMoveBy()</code></li>
<li><code>DOBlendablePunchRotation()</code></li>
</ul>
<h2 id="Material"><a href="#Material" class="headerlink" title="Material"></a><strong>Material</strong></h2><p><code>Material material = GetComponent&lt;MeshRenderer&gt;().material;</code></p>
<p><code>material.Func()</code></p>
<h3 id="color"><a href="#color" class="headerlink" title="color"></a>color</h3><ul>
<li><code>DOColor()</code>：传颜色属性名字</li>
<li><code>DOGradientColor()</code>：渐变颜色动画</li>
</ul>
<h3 id="alpha"><a href="#alpha" class="headerlink" title="alpha"></a>alpha</h3><ul>
<li><p><code>DOColor(Color.clear, time)</code>：通过改变颜色的透明度改变物体透明度</p>
</li>
<li><p><code>DOFade()</code></p>
</li>
</ul>
<h3 id="other-1"><a href="#other-1" class="headerlink" title="other"></a>other</h3><ul>
<li><code>DOOffset()</code>：动态改变uv坐标，可用于特效，如武器流光</li>
<li><code>DOVector()</code>：改变任意material四维向量值</li>
<li><code>DOBlendableColor()</code>：颜色混合</li>
</ul>
<h1 id="3-Tips"><a href="#3-Tips" class="headerlink" title="3. Tips"></a>3. Tips</h1><ul>
<li>函数命名与功能相关，每一类命名都有关键词</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>效率工具备忘录</title>
    <url>/2021/03/11/tech/EfficiencyTool/</url>
    <content><![CDATA[<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><ul>
<li><a href="http://www.1218.io/">Seer</a> 实现类似Mac OS下空格预览文件的功能。</li>
<li><a href="https://www.islide.cc/">iSlide</a> 基于PPT的插件工具，包含查找模板、图片、图标素材、设计配色、页面布局、智能优化等功能。</li>
<li><a href="https://everything.en.softonic.com/">Everything</a> 全局文件搜索</li>
<li><a href="http://www.wox.one/">Wox</a> 实现类似Mac OS下Spot Light的功能，搭配Everything食用更佳。</li>
<li><a href="https://github.com/microsoft/PowerToys/releases">PowerToys</a> 微软开发的开源效率工具，支持快速修改图片分辨率、批量文件重命名、Wox的大部分功能(暂时不支持与Everything配合使用)。<a href="https://docs.microsoft.com/zh-cn/windows/powertoys/">Microsoft PowerToys | Microsoft Docs</a></li>
<li><a href="https://www.typora.io/">Typora</a> 用过颜值最高的Markdown编辑器。</li>
</ul>
<span id="more"></span>
<h3 id="Mac-OS"><a href="#Mac-OS" class="headerlink" title="Mac OS"></a>Mac OS</h3><ul>
<li><strong>Bob</strong> 全局翻译软件</li>
<li><strong>MonitorControl</strong> 控制显示器亮度</li>
<li><strong>超级右键</strong> 右键菜单工具</li>
<li><strong>Xnip</strong> 截图工具，支持滚动截图</li>
<li><strong>Unsplash Wallpapers</strong> 壁纸</li>
<li><strong>Cheat Sheet</strong> 快捷键查看工具</li>
<li><strong>Keka</strong> 解压工具</li>
<li><strong>Tencent Lemon</strong> 管家</li>
<li><strong>Mos</strong> 鼠标优化</li>
<li><strong>Rectangle</strong> 窗口调整工具</li>
</ul>
<h3 id="Edge-Chrome插件"><a href="#Edge-Chrome插件" class="headerlink" title="Edge/Chrome插件"></a>Edge/Chrome插件</h3><ul>
<li><a href="https://microsoftedge.microsoft.com/addons/detail/adblock-—-最佳广告拦截工具/ndcileolkflehcjpmjnfbnaibdcgglog">AdBlock</a></li>
<li><a href="https://microsoftedge.microsoft.com/addons/detail/infinity-新标签页-pro/hajlmbnnniemimmaehcefkamdadpjlfa">Infinity 新标签页 (Pro)</a></li>
<li><a href="https://microsoftedge.microsoft.com/addons/detail/tampermonkey/iikmkjmpaadaobahmlepeloendndfphd">Tampermonkey</a></li>
<li><a href="">Imagus</a> 图片预览</li>
</ul>
<h3 id="JetBrains插件"><a href="#JetBrains插件" class="headerlink" title="JetBrains插件"></a>JetBrains插件</h3><ul>
<li><strong>Translation</strong> 翻译工具</li>
<li><strong>Nyan Progress Bar</strong> 彩虹猫进度条</li>
<li><strong>GitToolBox</strong> Git工具</li>
<li><strong>Chinese(Simplified) Language Pack EAP</strong> 汉化包</li>
<li><strong>CodeGlance</strong> 代码预览滚动条</li>
<li><strong>Background Image Plus</strong> 设置IDE背景</li>
<li><strong>Leetcode editor</strong> IDE刷Leetcode神器</li>
<li><strong>AIXcoder Code Completer</strong> 代码补全工具</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>图的基本概念</title>
    <url>/2021/12/11/tech/Graph/</url>
    <content><![CDATA[<ul>
<li><a href="/2021/12/12/tech/GraphSearch/index.html">图的盲目搜索</a></li>
<li><p><a href="/2021/12/13/tech/DijkstraAndAStar/index.html">图的最短路径算法——Dijkstra和A*</a></p>
</li>
<li><p><a href="/2021/12/23/tech/SPFA/index.html">图的最短路径算法——SPFA</a></p>
</li>
</ul>
<h3 id="一、图的基本概念"><a href="#一、图的基本概念" class="headerlink" title="一、图的基本概念"></a>一、图的基本概念</h3><ul>
<li><strong>连通图/非连通图</strong>：图中任意一个节点都可以通过一条路径到达所有的其他节点即为连通图，否则为非连通图。</li>
<li><strong>带权图</strong>：图的边可以带权，用于描述从一个节点到另一个节点的开销。</li>
<li><strong>致密图/稀疏图</strong>：边与节点的比率决定一个图是稀疏的还是致密的。在设计算法时需要考虑图是稀疏图还是致密图。</li>
<li><strong>有向图/无向图</strong>：边是有方向的图即有向图。实际使用时，有时为了数据结构的统一，也会将无向图当作有向图处理（即每条边都是双向的）。</li>
</ul>
<span id="more"></span>
<ul>
<li><p><strong>邻接矩阵</strong>：邻接矩阵用一个二维矩阵表示图的连接关系。其空间开销是O(N^2)，对于稀疏图来说，大部分元素都会浪费，因此不是很经济。</p>
<p><img data-src="/image/14-1.png" alt=" " style="zoom:100%;"/></p>
</li>
<li><p><strong>邻接表</strong>：邻接表以链表的形式储存每一个节点连接的节点（边）。其空间开销是O(N+E)，因为游戏中使用的图大多数都为稀疏图，所以一般使用邻接表表示图。</p>
<p><img data-src="/image/14-2.png" alt=" " style="zoom:100%;"/></p>
</li>
<li><p><strong>度/出度/入度</strong>：在无向图中，顶点 v 的度（Degree）是指依附于顶点 v 的边数，通常记为 TD(v)。在有向图中，顶点的度等于顶点的入度(In Degree)与顶点的出度之和。顶点v的入度是指以该顶点v为弧头的弧的数目，记为ID(v)；顶点 v 的出度（Out Degree）是指以该顶点 v 为弧尾的弧的数目，记为 OD(v)。所以，顶点 v 的度 TD(v)= ID(v) + OD(v)。</p>
</li>
</ul>
<h3 id="二、游戏中图的作用"><a href="#二、游戏中图的作用" class="headerlink" title="二、游戏中图的作用"></a>二、游戏中图的作用</h3><h4 id="导航图"><a href="#导航图" class="headerlink" title="导航图"></a>导航图</h4><ul>
<li>导航图包含了在一个游戏环境中智能体可以访问的所有位置和这些位置之间地所有连接。其中，节点通常表示关键区域的位置或者环境中的对象，边则代表了点与点之间的连接，边的开销可以根据具体的游戏定义，最简单的可以用两个节点之间的距离表示。</li>
<li>智能体并非限制在只能沿着导航图的边移动，而是可以移动到环境内任何无障碍的位置，导航图的作用事规划路径，具体可以参考导航算法。</li>
</ul>
<h4 id="依赖图"><a href="#依赖图" class="headerlink" title="依赖图"></a>依赖图</h4><ul>
<li>资源管理类游戏中，依赖图用来描述玩家可以利用的不同建筑物、材料、单元以及技术之间的依赖关系，可以清晰地显示每种类型的资源所需要的先决条件。</li>
</ul>
<h4 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h4><ul>
<li>状态图用于表示状态之间的切换关系，一个图就能表示一个问题的状态空间，其中节点表示可能的一种状态，边则表示两个状态之间的切换关系，比如Unity中的动画状态机。</li>
</ul>
<h3 id="三、图的邻接表实现"><a href="#三、图的邻接表实现" class="headerlink" title="三、图的邻接表实现"></a>三、图的邻接表实现</h3><p>由于游戏中普遍使用的是稀疏图，因此之后的搜索算法都使用图的邻接表算法实现。</p>
<p>邻接表由两部分构成：顶点节点和邻接表节点。顶点节点顺序储存，邻接表节点链式储存，其链接表示两个节点之间的边。具体实现如下。</p>
<h4 id="顶点数据类-Node-lt-T-gt"><a href="#顶点数据类-Node-lt-T-gt" class="headerlink" title="顶点数据类 Node&lt;T&gt;"></a>顶点数据类 <code>Node&lt;T&gt;</code></h4><p>为了通用和便于扩展，首先需要定义顶点数据类型，用于储存顶点的数据。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span>(<span class="params">T data</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T Data &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="顶点节点类-VexNode-lt-T-gt"><a href="#顶点节点类-VexNode-lt-T-gt" class="headerlink" title="顶点节点类 VexNode&lt;T&gt;"></a>顶点节点类 <code>VexNode&lt;T&gt;</code></h4><p>顶点节点包含两个域，一个储存顶点数据，另一个为邻接表第一个节点的引用。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VexNode</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VexNode</span>(<span class="params">Node&lt;T&gt; data, AdjNode&lt;T&gt; adjNode = <span class="literal">null</span></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Data = data;</span><br><span class="line">        FirstAdjNode = adjNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node&lt;T&gt; Data &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> AdjNode&lt;T&gt; FirstAdjNode &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="邻接表节点类-AdjNode-lt-T-gt"><a href="#邻接表节点类-AdjNode-lt-T-gt" class="headerlink" title="邻接表节点类 AdjNode&lt;T&gt;"></a>邻接表节点类 <code>AdjNode&lt;T&gt;</code></h4><p>邻接节点同样会储存顶点数据（为了方便查找对应的顶点节点）；边的数据也会存在邻接表节点中；以及，会包含一个指向下一个节点的引用。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AdjNode</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AdjNode</span>(<span class="params">Node&lt;T&gt; data, <span class="built_in">float</span> cost = <span class="number">0</span>, AdjNode&lt;T&gt; next = <span class="literal">null</span></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Data = data;</span><br><span class="line">        Next = next;</span><br><span class="line">        Cost = cost;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node&lt;T&gt; Data &#123; <span class="keyword">get</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Cost &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> AdjNode&lt;T&gt; Next &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="图类-Graph-lt-T-gt"><a href="#图类-Graph-lt-T-gt" class="headerlink" title="图类 Graph&lt;T&gt;"></a>图类 <code>Graph&lt;T&gt;</code></h4><ul>
<li><p>图需要储存所有的顶点节点，一般会采用List，这里为了方便查询，使用一个字典储存顶点节点，用顶点数据作为Key，这样，就不用经常性地遍历List。</p>
</li>
<li><p>由于顶点节点和邻接节点只有图知道，不对外暴露，所以外部代码只知道顶点数据类，图对外提供的各个方法中都以顶点数据类为参数。 </p>
</li>
<li>图需要对外提供各种基本的图操作方法，如判断节点、增删节点、判断边、增删边、修改边的权值等。</li>
<li>为了兼容有向图和无向图，在添加（删除）边的时候，无向图会自动添加（删除）两遍，正向一遍，反向一遍。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">public class Graph&lt;T&gt; : IEnumerable&lt;VexNode&lt;T&gt;&gt;, IGraph&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span>(<span class="params">Node&lt;T&gt;[] data</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        NodeDic = <span class="keyword">new</span> Dictionary&lt;Node&lt;T&gt;, VexNode&lt;T&gt;&gt;();</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> t <span class="keyword">in</span> data)</span><br><span class="line">        &#123;</span><br><span class="line">            NodeDic[t] = <span class="keyword">new</span> VexNode&lt;T&gt;(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        NodeDic = <span class="keyword">new</span> Dictionary&lt;Node&lt;T&gt;, VexNode&lt;T&gt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否为有向图</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> IsDigraph &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 顶点数目</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> NodeNum =&gt; NodeDic.Count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边的数目</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> EdgeNum</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> node <span class="keyword">in</span> NodeDic.Values)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> p = node.FirstAdjNode;</span><br><span class="line">                <span class="keyword">while</span> (p != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                    p = p.Next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> IsDigraph ? count : count / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> VexNode&lt;T&gt; <span class="keyword">this</span>[Node&lt;T&gt; node]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> =&gt; NodeDic[node];</span><br><span class="line">        <span class="keyword">set</span> =&gt; NodeDic[node] = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Dictionary&lt;Node&lt;T&gt;, VexNode&lt;T&gt;&gt; NodeDic;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断节点是否属于图</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsNode</span>(<span class="params">Node&lt;T&gt; node</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> NodeDic.TryGetValue(node, <span class="keyword">out</span> <span class="keyword">var</span> _);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断两点之间是否有边</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">HasEdge</span>(<span class="params">Node&lt;T&gt; <span class="keyword">from</span>, Node&lt;T&gt; to</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!IsNode(<span class="keyword">from</span>) || !IsNode(to))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;节点不属于图！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> p = NodeDic[<span class="keyword">from</span>].FirstAdjNode;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.Data == to)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            p = p.Next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddNode</span>(<span class="params">Node&lt;T&gt; node</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (IsNode(node))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(<span class="string">&quot;已经存在节点！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NodeDic[node] = <span class="keyword">new</span> VexNode&lt;T&gt;(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在两节点之间添加边</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddEdge</span>(<span class="params">Node&lt;T&gt; <span class="keyword">from</span>, Node&lt;T&gt; to, <span class="built_in">int</span> cost = <span class="number">1</span></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!IsNode(<span class="keyword">from</span>) || !IsNode(to))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(<span class="string">&quot;节点不属于图！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (HasEdge(<span class="keyword">from</span>, to))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(<span class="string">&quot;边已经存在！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> p = <span class="keyword">new</span> AdjNode&lt;T&gt;(to, cost);</span><br><span class="line">        <span class="keyword">var</span> firstNode = NodeDic[<span class="keyword">from</span>].FirstAdjNode;</span><br><span class="line">        <span class="keyword">if</span> (firstNode == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            NodeDic[<span class="keyword">from</span>].FirstAdjNode = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p.Next = firstNode;</span><br><span class="line">            NodeDic[<span class="keyword">from</span>].FirstAdjNode = p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (IsDigraph) <span class="keyword">return</span>;</span><br><span class="line">        p = <span class="keyword">new</span> AdjNode&lt;T&gt;(<span class="keyword">from</span>, cost);</span><br><span class="line">        firstNode = NodeDic[to].FirstAdjNode;</span><br><span class="line">        <span class="keyword">if</span> (firstNode == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            NodeDic[to].FirstAdjNode = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p.Next = firstNode;</span><br><span class="line">            NodeDic[to].FirstAdjNode = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除边</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveEdge</span>(<span class="params">Node&lt;T&gt; <span class="keyword">from</span>, Node&lt;T&gt; to</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!IsNode(<span class="keyword">from</span>) || !IsNode(to))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(<span class="string">&quot;节点不属于图！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!HasEdge(<span class="keyword">from</span>, to))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(<span class="string">&quot;边不存在！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> p = NodeDic[<span class="keyword">from</span>].FirstAdjNode;</span><br><span class="line">        AdjNode&lt;T&gt; pre = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.Data == to) <span class="keyword">break</span>;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = p.Next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pre.Next = p.Next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (IsDigraph) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        p = NodeDic[to].FirstAdjNode;</span><br><span class="line">        pre = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.Data == <span class="keyword">from</span>) <span class="keyword">break</span>;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = p.Next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pre.Next = p.Next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变边的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangeEdgeCost</span>(<span class="params">Node&lt;T&gt; <span class="keyword">from</span>, Node&lt;T&gt; to, <span class="built_in">float</span> cost</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!IsNode(<span class="keyword">from</span>) || !IsNode(to))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(<span class="string">&quot;节点不属于图！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!HasEdge(<span class="keyword">from</span>, to))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(<span class="string">&quot;边不存在！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> p = NodeDic[<span class="keyword">from</span>].FirstAdjNode;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.Data == to) <span class="keyword">break</span>;</span><br><span class="line">            p = p.Next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p.Cost = cost;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (IsDigraph) <span class="keyword">return</span>;</span><br><span class="line">        p = NodeDic[to].FirstAdjNode;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.Data == <span class="keyword">from</span>) <span class="keyword">break</span>;</span><br><span class="line">            p = p.Next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p.Cost = cost;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IEnumerator&lt;VexNode&lt;T&gt;&gt; GetEnumerator()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> NodeDic.Values.GetEnumerator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IEnumerator IEnumerable.GetEnumerator()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> GetEnumerator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>参考资料：</strong></p>
<ul>
<li>《游戏人工智能编程案例精粹》第5章：图的秘密生命</li>
<li><a href="https://www.cnblogs.com/SimplePoint/p/9270805.html">【C#数据结构系列】图 - 宇霍飞</a></li>
</ul>
<p><strong>Demo地址：</strong><a href="https://github.com/Luciano-0/Graph.git">https://github.com/Luciano-0/Graph.git</a></p>
]]></content>
      <tags>
        <tag>Graph</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>图的盲目搜索</title>
    <url>/2021/12/12/tech/GraphSearch/</url>
    <content><![CDATA[<ul>
<li><p><a href="/2021/12/11/tech/Graph/index.html">图的基本概念</a></p>
</li>
<li><p><a href="/2021/12/13/tech/DijkstraAndAStar/index.html">图的最短路径算法——Dijkstra和A*</a></p>
</li>
<li><p><a href="/2021/12/23/tech/SPFA/index.html">图的最短路径算法——SPFA</a></p>
</li>
</ul>
<p>图的盲目搜索指的是不考虑边的开销的条件下的搜索。通常是为了遍历一个图或是找到一条两点之间的任意路径。盲目搜索分为深度优先搜索和广度优先搜索，它们的思想和实现同树的先序遍历、层序遍历很相似（毕竟树是图的子集）。</p>
<span id="more"></span>
<h3 id="一、深度优先搜索（Depth-First-Search）"><a href="#一、深度优先搜索（Depth-First-Search）" class="headerlink" title="一、深度优先搜索（Depth First Search）"></a>一、深度优先搜索（Depth First Search）</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>深度优先搜索总是尽可能地深入一个图，当走到死胡同时才开始回溯，回到上一个点继续搜索。类比树的先序遍历就容易想到可以通过栈或是递归实现。我们需要定义一个栈Stack用于储存待搜索的节点，定义一个集合Visited用于储存搜索过的节点，每搜索到一个节点，将其相邻的没有搜索过的节点压入Stack，将其自身加入Visited。由于栈的先入后出原则，可以保证优先遍历下一层的节点而非同一层的相邻节点。知道栈清空就表示搜索完毕。该算法能实现连通图的遍历，若是非连通图则还需要做特殊处理。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">DFS</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="title">List</span>&lt;<span class="title">Node</span>&lt;<span class="title">T</span>&gt;&gt; result</span> = <span class="keyword">new</span> List&lt;Node&lt;T&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Graph&lt;T&gt; graph;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="title">HashSet</span>&lt;<span class="title">Node</span>&lt;<span class="title">T</span>&gt;&gt; visited</span> = <span class="keyword">new</span> HashSet&lt;Node&lt;T&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归版本</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Node&lt;T&gt;&gt; DFSSearchRecursive(Graph&lt;T&gt; g, Node&lt;T&gt; start)</span><br><span class="line">    &#123;</span><br><span class="line">        result.Clear();</span><br><span class="line">        <span class="keyword">if</span> (g == <span class="literal">null</span> || g.NodeNum == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(<span class="string">&quot;图为空！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        graph = g;</span><br><span class="line">        visited.Clear();</span><br><span class="line">        DFSCore(start);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DFSCore</span>(<span class="params">Node&lt;T&gt; node</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        visited.Add(node);</span><br><span class="line">        result.Add(node);</span><br><span class="line">        <span class="keyword">var</span> adjNode = graph[node].FirstAdjNode;</span><br><span class="line">        <span class="keyword">while</span> (adjNode != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited.Contains(adjNode.Data))</span><br><span class="line">            &#123;</span><br><span class="line">                DFSCore(adjNode.Data);</span><br><span class="line">            &#125;</span><br><span class="line">            adjNode = adjNode.Next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非递归版本</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Node&lt;T&gt;&gt; DFSSearchStack(Graph&lt;T&gt; graph,Node&lt;T&gt; start)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (graph == <span class="literal">null</span> || graph.NodeNum == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(<span class="string">&quot;图为空！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> List&lt;Node&lt;T&gt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> stack = <span class="keyword">new</span> Stack&lt;Node&lt;T&gt;&gt;();</span><br><span class="line">        <span class="keyword">var</span> visited = <span class="keyword">new</span> HashSet&lt;Node&lt;T&gt;&gt;();</span><br><span class="line">        <span class="keyword">var</span> res = <span class="keyword">new</span> List&lt;Node&lt;T&gt;&gt;();</span><br><span class="line">        stack.Push(start);</span><br><span class="line">        <span class="keyword">while</span> (stack.Count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> node = stack.Pop();</span><br><span class="line">            <span class="keyword">if</span> (visited.Contains(node)) <span class="keyword">continue</span>;</span><br><span class="line">            visited.Add(node);</span><br><span class="line">            res.Add(node);</span><br><span class="line">            <span class="keyword">var</span> adjNode = graph[node].FirstAdjNode;</span><br><span class="line">            <span class="keyword">while</span> (adjNode != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                stack.Push(adjNode.Data);</span><br><span class="line">                adjNode = adjNode.Next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>当一个问题的状态空间非常复杂，复杂到无法在开始之前就创建好整个状态空间的图，只能在每一步进行节点的扩展，此时深度优先搜索就有可能在错误的路径上陷得非常深，甚至无法回来。一种解决办法是限制搜索的深度，到达深度限制后就自动回溯。但要将深度限制设置为多少才合适又成了一个问题，针对这个问题，可以使用<strong>迭代加深深度优先搜索</strong>，顾名思义，就是一开始将搜索深度设置为较小值，若没有搜索到则再加大搜索深度，直到完成为止。</p>
<h3 id="二、广度优先搜索（Breadth-First-Search）"><a href="#二、广度优先搜索（Breadth-First-Search）" class="headerlink" title="二、广度优先搜索（Breadth First Search）"></a>二、广度优先搜索（Breadth First Search）</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>广度优先搜索从源节点开始检查从它出发的每一个节点，然后再从刚检查过的节点继续展开，相比于深度优先搜索，广度优先搜索可以找到达到目标节点的最优路径（包含最少边数的路径）。其实现与广度优先搜索类似，只需要将栈改成队列，队列的先进先出原则可以保证优先遍历当前节点同一层级的节点而非下一层级的节点。</p>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Node&lt;T&gt;&gt; BFSSearchRecursive(Graph&lt;T&gt; graph, Node&lt;T&gt; start)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (graph == <span class="literal">null</span> || graph.NodeNum == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(<span class="string">&quot;图为空！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> List&lt;Node&lt;T&gt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> queue = <span class="keyword">new</span> Queue&lt;Node&lt;T&gt;&gt;();</span><br><span class="line">        <span class="keyword">var</span> visited = <span class="keyword">new</span> HashSet&lt;Node&lt;T&gt;&gt;();</span><br><span class="line">        <span class="keyword">var</span> res = <span class="keyword">new</span> List&lt;Node&lt;T&gt;&gt;();</span><br><span class="line">        queue.Enqueue(start);</span><br><span class="line">        <span class="keyword">while</span> (queue.Count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> node = queue.Dequeue();</span><br><span class="line">            <span class="keyword">if</span> (visited.Contains(node)) <span class="keyword">continue</span>;</span><br><span class="line">            visited.Add(node);</span><br><span class="line">            res.Add(node);</span><br><span class="line">            <span class="keyword">var</span> adjNode = graph[node].FirstAdjNode;</span><br><span class="line">            <span class="keyword">while</span> (adjNode != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                queue.Enqueue(adjNode.Data);</span><br><span class="line">                adjNode = adjNode.Next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><p>广度优先搜索除了搜索小空间之外，在其他地方使用会显得比较笨拙，假设分枝数为b，深度为d，则我们需要检测的节点数为</p>
<script type="math/tex; mode=display">
1+b^1+b^2+...+b^d</script><p>如果被搜索的图分支数非常高，那么搜索效率将非常低。当状态空间复杂到需要一边搜索一遍扩展节点时，搜索将更加耗时。</p>
<p><strong>参考资料：</strong></p>
<ul>
<li>《人工智能编程案例精粹》第5章：图的秘密生命</li>
<li><a href="https://www.cnblogs.com/SimplePoint/p/9270805.html">【C#数据结构系列】图 - 宇霍飞</a></li>
</ul>
<p><strong>Demo地址：</strong><a href="https://github.com/Luciano-0/Graph.git">https://github.com/Luciano-0/Graph.git</a></p>
]]></content>
      <tags>
        <tag>Graph</tag>
        <tag>AI</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏中的运动补偿</title>
    <url>/2020/11/22/tech/MotionCompensation/</url>
    <content><![CDATA[<h2 id="玩家角色的客户端预测与服务器对账"><a href="#玩家角色的客户端预测与服务器对账" class="headerlink" title="玩家角色的客户端预测与服务器对账"></a>玩家角色的客户端预测与服务器对账</h2><h3 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h3><ul>
<li><p>在多人游戏中，外挂作弊不只是让自己的游戏体验更好，还会让其他玩家的游戏体验更差，因此在开发过程中需要避免这种情况的发生。</p>
</li>
<li><p><strong>权威服务器和哑客户端</strong>：为处理外挂问题，游戏中的逻辑通常只由服务器处理，客户端只负责显示，一切以服务器为准。</p>
</li>
<li><p>此方案在慢节奏的游戏中运行良好，但遇到快速刷新的游戏就要考虑网络延迟的问题。比如考虑一个实际场景，客户端发出指令向前运动一米，指令需要传给服务器（花费100 ms），服务器处理后返回角色运动一米后所在的位置（花费100 ms），再由客户端在画面上表现出来。因此在玩家发出指令后将在200 ms内游戏画面没有任何变化然后突然向前运动了一米。这种滞后对游戏来说当然是灾难性的。</p>
<span id="more"></span>
</li>
</ul>
<h3 id="客户端预测"><a href="#客户端预测" class="headerlink" title="客户端预测"></a>客户端预测</h3><ul>
<li>通常游戏世界是具有足够确定性的，即给定一个游戏状态和一组输入，结果是完全可预测的。因此基于此确定性，我们可以在客户端发出指令之后在等待服务器回应期间就开始呈现效果，这样既保证了服务器的权威性，又能消除表现上的割裂感。</li>
<li>以上方案看似已经完美解决了问题，但考虑一下当玩家的连续操作时间间隔小于网络延迟的时候就会出现问题。比如：玩家连续按下两次向前移动一米的操作，移动所需时间为100 ms，但网络延迟有250 ms，这就会导致在200 ms时角色在前进两米的位置，但250 ms时收到服务器的第一次消息强制更新回到前进一米的位置，而在350 ms时又会更新到前进两米的位置。这一问题就需要服务器对账来解决。</li>
</ul>
<h3 id="服务器对账"><a href="#服务器对账" class="headerlink" title="服务器对账"></a>服务器对账</h3><ul>
<li>在客户端向服务器发送请求时加入一个序号，当服务器回复时，包括它处理的最后一个序号。借此客户端可以根据服务器发送的最后一个权威的状态以及服务器未处理的输入计算游戏当前的状态。</li>
</ul>
<h2 id="多人游戏其他玩家：实体插值和滞后补偿"><a href="#多人游戏其他玩家：实体插值和滞后补偿" class="headerlink" title="多人游戏其他玩家：实体插值和滞后补偿"></a>多人游戏其他玩家：实体插值和滞后补偿</h2><h3 id="多人游戏带来的新问题"><a href="#多人游戏带来的新问题" class="headerlink" title="多人游戏带来的新问题"></a>多人游戏带来的新问题</h3><ul>
<li><strong>服务器时间步进</strong>：当有多个客户端同时高频次地向服务器发送请求时，每次输入都更新游戏世界会消耗太多的CPU和带宽，因此通常会对客户端的输入进行排队，设置一个服务器步进时间，如100 ms，在该时间段内对所有收到的操作进行统一处理并广播给客户端。</li>
<li><strong>客户端处理低频更新</strong>：对于玩家自己控制的角色来说处理和前文所述基本一致，能靠预测填充服务器两次消息间信息的空白，但是对于其他玩家控制的角色来说，获得的信息就会比较稀疏，如何在数据有限的情况下对其他玩家控制角色的运动进行平滑就是新的问题。</li>
</ul>
<h3 id="Dead-reckoning-死亡计算"><a href="#Dead-reckoning-死亡计算" class="headerlink" title="Dead reckoning 死亡计算"></a>Dead reckoning 死亡计算</h3><ul>
<li><p>在某些游戏如赛车游戏中，客户端可以获取权威的速度、加速度等运动参数，在下一次服务器数据到来之前，假设在此期间汽车不发生运动参数的突变（如发生碰撞、用户输入等），客户端根据当前参数预测汽车的运动，在服务器数据到来之后进行更正。</p>
</li>
<li><p><strong>限制：</strong>在某些情况下，死亡计算完全无法使用，例如在射击游戏中，玩家的方向和速度是可以立刻改变的，此时，玩家以较高的频率和飞快的速度进行转向、加速、停止，因此，完全无法根据当前的运动参数预测接下来的运动。</p>
</li>
</ul>
<h3 id="实体插值"><a href="#实体插值" class="headerlink" title="实体插值"></a>实体插值</h3><ul>
<li>另一种解决方法是实体插值，例如，在t=1000 ms时，客户端已经收到了来自服务器t=900 ms和t=1000 ms的可靠数据，在1000 ms到1100 ms期间，客户端就显示对900 ms和1000 ms插值之后的数据。在此种解决方案下，插值获得的显示效果是流畅且足够准确的，唯一的问题是客户端显示的是100 ms前的数据。 </li>
</ul>
<h3 id="滞后补偿"><a href="#滞后补偿" class="headerlink" title="滞后补偿"></a>滞后补偿</h3><ul>
<li><strong>最后需要解决一个问题：</strong>实体插值带来的延迟。当下，玩家看到的实际是自己当前的位置状态和100 ms前其他玩家的位置状态。在某些情况下，这100 ms的延迟也是致命的，如：你向着敌人开枪，但你瞄准的实际上是100 ms前的敌人，此时敌人的位置已经不在你看到的位置。</li>
<li><strong>解决方案：</strong>当玩家按下射击按钮时，客户端会向服务器发送当前事件，包含准确的时间戳和目标。服务器接收到数据后会根据时间戳重建过去的世界，处理射击的结果并发送给客户端。唯一的问题是敌人有可能在掩体后被杀，因为他实际上是在100 ms前运动到掩体前被杀的，但做了延迟处决。</li>
</ul>
<p>参考：</p>
<p><a href="https://www.gabrielgambetta.com/client-server-game-architecture.html">Client Server Game Architecture</a></p>
<p><a href="https://developer.valvesoftware.com/wiki/Latency_Compensating_Methods_in_Client/Server_In-game_Protocol_Design_and_Optimization#Game_Design_Implications_of_Lag_Compensation">Latency Compensating Methods in Client/Server In-game Protocol Design and Optimization</a></p>
]]></content>
      <tags>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title>基于NodeCanvas的AI框架</title>
    <url>/2021/11/15/tech/NodeCanvas/</url>
    <content><![CDATA[<h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p>之前项目中重构过AI的框架，基于NodeCanvas实现，不过现在项目已经无了，所以想总结下之前重构的思路，做个备忘。</p>
<h3 id="二、设计目的"><a href="#二、设计目的" class="headerlink" title="二、设计目的"></a>二、设计目的</h3><ul>
<li><strong>实现行为树与客户端逻辑的解耦：</strong>作为Plugin，保证行为树框架层面没有客户端相关的逻辑和数据，即行为树只负责根据数据做决策，不知晓上层具体的游戏逻辑，可以实现行为树框架在不同游戏之间的移植。</li>
</ul>
<span id="more"></span>
<ul>
<li><strong>对现有的行为树Task做扩展：</strong>使其能够满足策划的行为树配置需求，兼顾配置过程的灵活性和易用性。应对变化的需求需满足开闭原则。</li>
<li><strong>同时支持控制游戏玩法：</strong>行为树不光需要控制游戏角色，还需要支持控制某一特定玩法。在某一玩法中，实现行为树的分层，即不光有每个游戏个体的行为树，还有控制整体玩法流程的行为树。</li>
</ul>
<h3 id="三、实现方案"><a href="#三、实现方案" class="headerlink" title="三、实现方案"></a>三、实现方案</h3><h4 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h4><p><img data-src="/image/16-3.png" alt=" " style="zoom:100%;"/></p>
<h4 id="黑板"><a href="#黑板" class="headerlink" title="黑板"></a>黑板</h4><h5 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>NodeCanvas中的黑板细分可分为三种：全局黑板、Obj黑板，Asset黑板，区别如下：</p>
<ul>
<li><strong>全局黑板</strong></li>
</ul>
<p>全局黑板挂载在游戏物体上，可以同时存在多个全局黑板，通过唯一的Identifier区分。客户端可以通过获得游戏物体上的GlobalBlackboard组件读写黑板上的变量。任何行为树可以在变量选择的下拉菜单中选择场景中存在的全局黑板变量。</p>
<p><img data-src="/image/16-1.png" alt=" " style="zoom:100%;"/></p>
<ul>
<li><strong>Asset黑板</strong></li>
</ul>
<p>Asset黑板存在于行为树中，和行为树一起保存在Asset文件中，客户端可以通过行为树获取到其中的blackboard。Asset黑板无法储存场景中的引用。</p>
<ul>
<li><strong>Obj黑板</strong></li>
</ul>
<p>在编辑器中，给物体挂上BehaviorTreeOwner时，会自动添加Obj黑板，该黑板会与游戏物体绑定，可以储存场景中的引用。和全局黑板一样也可以通过获取物体上的组件来获取它。但因为游戏中的行为树脚本都需要动态加载，所以使用的都是Asset黑板，没有用到Obj黑板。</p>
<h5 id="框架中黑板的使用"><a href="#框架中黑板的使用" class="headerlink" title="框架中黑板的使用"></a>框架中黑板的使用</h5><p>在该AI框架中，客户端和行为树之间传递数据大多依赖黑板。</p>
<ul>
<li>对于AI物体自身的数据（如怪物的血量、状态等）都通过自身行为树上的黑板储存交换。游戏层通过IAIUnit管理此黑板，对外提供交换数据的接口。</li>
<li>对于全局的数据（如全局游戏状态，场景数据、任务数据等）通过全局黑板储存交换，游戏层通过单例AIManager管理多个全局黑板，对外提供交换数据的接口。</li>
<li>客户端和行为树的数据交换有两种模式：<ul>
<li><strong>推模式</strong>：客户端主动将数据写入黑板，需要提前定义好所需的数据，并保证在数据更新时都能通知到黑板。</li>
<li><strong>拉模式</strong>：在行为树需要数据时通过命令告诉客户端，客户端将数据写入对应黑板的变量，需要提前定义好命令和相应的变量。</li>
</ul>
</li>
</ul>
<h4 id="命令接收器"><a href="#命令接收器" class="headerlink" title="命令接收器"></a>命令接收器</h4><p>为了将具体的逻辑代码从行为树中移到客户端，添加了客户端和行为树之间命令收发的机制。命令接收器是除了黑板外第二个重要的客户端和行为树交换数据的桥梁，起到转移命令的作用。</p>
<h5 id="ICammandReceiver"><a href="#ICammandReceiver" class="headerlink" title="ICammandReceiver"></a>ICammandReceiver</h5><p>在行为树层定义接口ICammandReceiver，客户端的CommandManager实现具体方法。需要接收命令的模块持有一个cmdReceiver，将需要相应的命令接收器写到行为树黑板上，行为树就可以选择对应的命令接收器触发命令了。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICommandReceiver</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ExecuteCmd</span>(<span class="params">CommandEnum name, Action&lt;<span class="built_in">bool</span>&gt; callback = <span class="literal">null</span></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ExecuteCmd</span>&lt;<span class="title">T</span>&gt;(<span class="params">CommandEnum name, T param, Action&lt;<span class="built_in">bool</span>&gt; callback = <span class="literal">null</span></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ExecuteCmd</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt;(<span class="params">CommandEnum name, T1 param1, T2 param2,</span></span></span><br><span class="line"><span class="function"><span class="params">    Action&lt;<span class="built_in">bool</span>&gt; callback = <span class="literal">null</span></span>)</span>;</span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">ConditionCheck</span>(<span class="params">CommandEnum name</span>)</span>;</span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">ConditionCheck</span>&lt;<span class="title">T</span>&gt;(<span class="params">CommandEnum name, T param</span>)</span>;</span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">ConditionCheck</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt;(<span class="params">CommandEnum name, T1 param1, T2 param2</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="AI单位：IAIUnit"><a href="#AI单位：IAIUnit" class="headerlink" title="AI单位：IAIUnit"></a>AI单位：IAIUnit</h5><p>IAIUnit为游戏中的AI单位接口，其中包含行为树、黑板和命令接收器，并需要实现初始化、创建启停AI、读写变量的方法。任何需要受到行为树控制的模块需要实现IAIUnit，如角色单位AIUnit和玩法AIGamePlay。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IAIUnit</span></span><br><span class="line">&#123;</span><br><span class="line">    BehaviourTreeOwner BtOwner &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    IBlackboard MyBlackboard &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    ICommandReceiver CmdReceiver &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InitCmd</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">StartAI</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">StopAI</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DestroyAI</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ChangeAI</span>(<span class="params">BehaviourTree bt</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetVariable</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> name, T <span class="keyword">value</span></span>)</span>;</span><br><span class="line">    <span class="function">T <span class="title">GetVariable</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> name</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CreateAI</span>(<span class="params">GameObject go, BehaviourTree bt</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="全局AI管理器：AIManager"><a href="#全局AI管理器：AIManager" class="headerlink" title="全局AI管理器：AIManager"></a>全局AI管理器：AIManager</h4><p>AIMamager为客户端的AI管理器。</p>
<ul>
<li>维护所有AI单位，对外提供创建删除和启停AI的接口，创建时完成游戏物体和AI的绑定，所有角色的AI以ID为索引储存到AIManager中，当玩法的AI创建后也会储存在AIManager中。若行为树之间需要数据的传递和通信就可以通过AIManager进行。</li>
<li>维护全局黑板，包括全局黑板的创建、提供读写变量的接口。</li>
<li>维护全局命令接收器。当行为树发出全局相关的指令时就由AIManager执行。</li>
</ul>
<h3 id="四、遇到的问题和🕳"><a href="#四、遇到的问题和🕳" class="headerlink" title="四、遇到的问题和🕳"></a>四、遇到的问题和🕳</h3><ul>
<li><p><strong>Task对泛型的扩展</strong></p>
<p>由于NodeCavas只支持一个泛型参数的Task，而要想将发送命令Task做的通用，满足带任意类型、任意多个参数还能定义任意类型的返回值就遇到了较大的限制。目前对源码进行了扩展，使其能够支持两个参数泛型类的创建。但随着参数个数增加，逻辑复杂度和性能会呈指数级上升，原因在于底层会在编辑时打开泛型菜单时就把所有类创建完毕，如果Unity中的类型有100种，那么一个泛型只需要创建100+100（List<T>）+100(Dictionary<string,T>)种，两个泛型就有300*300种，当个数达到三个时复杂度就已经超出承受范围了。目前两个参数已经能满足大部分的需求，后续在这块上再考虑如何优化突破限制。</p>
</li>
<li><p><strong>打包后类型丢失</strong></p>
<p>当行为树中有增删类型或是增加新的泛型Task时，在打包前需要世界之树（Giant Tree）/类型管理（Types Editor）中重新生成AOTClasses.cs和link.xml文件，以防止类型被裁减。</p>
</li>
</ul>
<p><img data-src="/image/16-2.png" alt=" " style="zoom:100%;"/></p>
<ul>
<li>性能相关问题<ul>
<li>在开启行为树时，会根据行为树资源Clone一个新的实例，这块涉及到Json的反序列化，性能开销较大。因此在GraphOwner中使用字典<code>private Dictionary&lt;Graph, Graph&gt; instances = new Dictionary&lt;Graph, Graph&gt;();</code>对实例进行了缓存，key为graph源文件，value为实例，只要GraphOwner不被销毁，反复开启行为树不会有额外的开销。</li>
<li>同时，在外部（加载Asset的地方）还需要对行为树Asset文件做对象池，在反复刷怪时可以避免反复加载资源文件。</li>
<li>在Variable类中禁止类型自动转换，可以避免类型转换带来的拆装箱。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>AI</tag>
        <tag>NodeCanvas</tag>
      </tags>
  </entry>
  <entry>
    <title>初见Processing</title>
    <url>/2020/10/18/tech/Processing-1/</url>
    <content><![CDATA[<h2 id="新大陆"><a href="#新大陆" class="headerlink" title="新大陆"></a>新大陆</h2><p>前几天开始看 Daniel Shiffman的<a href="https://book.douban.com/subject/26264736/">《代码本色：用编程模拟自然系统》</a>，接触到了Processing这种编程语言，就像发现了新大陆。Processing号称为艺术而生的语言，确实，从使用体验到运行效果，都能透露出一份独特的优雅。</p>
<span id="more"></span>
<p>Processing设计的思路就是使用图形化替代原来的命令行，正是这种初衷赋予了这门语言生命，编写几行简单的代码，点击运行按钮就能看到生动的演示效果。</p>
<p>在使用体验上，Processing简单但不简陋，下载后直接打开就能进行编程，不需要复杂的配置环境过程。窗口有点类似单片机的编程，而编程体验类似于Python，且由于开放的社区环境，有许多功能强大的扩展包可以安装。</p>
<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ul>
<li><a href="https://processing.org">官网</a></li>
<li><a href="http://iprocessing.cn/文档/">文档</a></li>
<li>社区：<a href="https://www.openprocessing.org">OpenProcessing</a> / <a href="http://iprocessing.cn">Processing编程艺术</a></li>
<li>书籍：<a href="https://book.douban.com/subject/3143256/">Learning Processing</a> / <a href="https://book.douban.com/subject/20452058/">The Nature of Code</a></li>
</ul>
]]></content>
      <tags>
        <tag>Processing</tag>
      </tags>
  </entry>
  <entry>
    <title>一种Lua反射调用C#机制的实现</title>
    <url>/2021/04/09/tech/NativeChannel/</url>
    <content><![CDATA[<h4 id="一-概述"><a href="#一-概述" class="headerlink" title="一   概述"></a>一   概述</h4><p>NativeChannel提供Lua层通过反射调用C#层代码的机制，支持对静态类和非静态类中属性、方法、委托的调用，并支持在Lua层使用宏定义对代码进行隔离。通过NativeChannel可以不生成额外的wrap文件来达到Lua层访问C#层的效果，调用更加灵活，适合需要集成到Lua层但又要灵活增删的模块（如SDK）。</p>
<span id="more"></span>
<h4 id="二-实现"><a href="#二-实现" class="headerlink" title="二   实现"></a>二   实现</h4><p>实现的大致思路为封装两个类<code>AnyObject</code>和<code>AnyStaticObject</code>暴露到Lua层，这两个类都实现<code>IAny</code>接口。这两个类包含对具体类中的生命周期、属性、方法、委托的所有操作。再定义通道类<code>NativeChannel</code>，实现INativeChannel和<code>IServiceStart</code>接口，包装成Service管理所有反射调用的类。</p>
<h5 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h5><ul>
<li>Interface</li>
</ul>
<p><code>AnyObject</code>和<code>AnyStaticObject</code>都实现了<code>IAny</code>接口，它们之间的区别是前者储存了目标类实例的引用<code>target</code>，在使用时调用属性、方法需要传入该引用；而后者储存的是静态类的类型。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IAny</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">OnStart</span>(<span class="params"></span>)</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">OnUpdate</span>(<span class="params"><span class="built_in">float</span> deltaTime</span>)</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">OnEnd</span>(<span class="params"></span>)</span>;</span><br><span class="line">	<span class="function"><span class="built_in">object</span> <span class="title">Get</span>(<span class="params"><span class="built_in">string</span> prop</span>)</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Set</span>(<span class="params"><span class="built_in">string</span> prop, <span class="built_in">object</span> <span class="keyword">value</span></span>)</span>;</span><br><span class="line">	<span class="function"><span class="built_in">object</span> <span class="title">Call</span>(<span class="params"><span class="built_in">string</span> method, <span class="keyword">params</span> <span class="built_in">object</span>[] args</span>)</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">AddDelegate</span>(<span class="params"><span class="built_in">string</span> del, <span class="built_in">string</span> func, LuaTable self = <span class="literal">null</span></span>)</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">AddDelegate</span>(<span class="params"><span class="built_in">string</span> del, LuaFunction func</span>)</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">RemoveDelegate</span>(<span class="params"><span class="built_in">string</span> del, <span class="built_in">string</span> func, LuaTable self = <span class="literal">null</span></span>)</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">RemoveDelegate</span>(<span class="params"><span class="built_in">string</span> del, LuaFunction func</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Life cycle</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnStart</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> method = <span class="keyword">this</span>.target.GetType().GetMethod(<span class="string">&quot;OnStart&quot;</span>);</span><br><span class="line">	method?.Invoke(<span class="keyword">this</span>.target, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>(<span class="params"><span class="built_in">float</span> deltaTime</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> method = <span class="keyword">this</span>.target.GetType().GetMethod(<span class="string">&quot;OnRefresh&quot;</span>);</span><br><span class="line">	Object[] p = <span class="keyword">new</span> Object[] &#123;deltaTime&#125;;</span><br><span class="line">	method?.Invoke(<span class="keyword">this</span>.target, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEnd</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> method = <span class="keyword">this</span>.target.GetType().GetMethod(<span class="string">&quot;OnEnd&quot;</span>);</span><br><span class="line">	method?.Invoke(<span class="keyword">this</span>.target, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Property</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">Get</span>(<span class="params"><span class="built_in">string</span> prop</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.target.GetType().GetProperty(prop)?.GetValue(<span class="keyword">this</span>.target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Set</span>(<span class="params"><span class="built_in">string</span> prop, <span class="built_in">object</span> <span class="keyword">value</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> propInfo = <span class="keyword">this</span>.target.GetType().GetProperty(prop);</span><br><span class="line">	<span class="keyword">if</span> (propInfo != <span class="literal">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">value</span> = ConvertType(propInfo.PropertyType, <span class="keyword">value</span>);</span><br><span class="line">		propInfo?.SetValue(<span class="keyword">this</span>.target, <span class="keyword">value</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Method</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">Call</span>(<span class="params"><span class="built_in">string</span> method, <span class="keyword">params</span> <span class="built_in">object</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> methodInfo = <span class="keyword">this</span>.target.GetType().GetMethod(method);</span><br><span class="line">	<span class="keyword">var</span> parameters = methodInfo?.GetParameters();</span><br><span class="line">	<span class="keyword">if</span> (args.Length != parameters?.Length)</span><br><span class="line">	&#123;</span><br><span class="line">		Debug.LogError(<span class="string">&quot;Wrong parameters!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; parameters.Length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		args[i] = ConvertType(parameters[i].ParameterType, args[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> methodInfo?.Invoke(<span class="keyword">this</span>.target, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Delegate</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddDelegate</span>(<span class="params"><span class="built_in">string</span> del, <span class="built_in">string</span> func, LuaTable self = <span class="literal">null</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> eventInfo = <span class="keyword">this</span>.target.GetType().GetEvent(del);</span><br><span class="line">	<span class="keyword">var</span> eventHandlerType = eventInfo.EventHandlerType;</span><br><span class="line">	<span class="keyword">var</span> eventArgs = eventHandlerType.GetMethod(<span class="string">&quot;Invoke&quot;</span>)?.GetParameters();</span><br><span class="line">	Type type;</span><br><span class="line">	<span class="keyword">if</span> (eventArgs == <span class="literal">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		type = <span class="literal">null</span>;</span><br><span class="line">		eventHandlerType = <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> args = <span class="keyword">new</span> Type[eventArgs.Length];</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; eventArgs.Length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		args[i] = eventArgs[i].ParameterType;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (eventArgs.Length)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		type = <span class="keyword">typeof</span>(Handler);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		type = <span class="keyword">typeof</span>(Handler&lt;&gt;).MakeGenericType(args);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">		<span class="literal">default</span>:</span><br><span class="line">		type = <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (type == <span class="literal">null</span> || eventHandlerType == <span class="literal">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> helper = Activator.CreateInstance(type, func, self);</span><br><span class="line">	<span class="keyword">var</span> handler = Delegate.CreateDelegate(eventHandlerType, helper, <span class="string">&quot;Handle&quot;</span>);</span><br><span class="line">	eventInfo.AddEventHandler(<span class="keyword">this</span>.target, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="NativeChannel"><a href="#NativeChannel" class="headerlink" title="NativeChannel"></a>NativeChannel</h5><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">LuaUsage</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">INativeChannel</span></span><br><span class="line">&#123;</span><br><span class="line">	[<span class="meta">LuaIgnore</span>]</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Register</span>(<span class="params"><span class="built_in">string</span> name, Func&lt;<span class="built_in">object</span>&gt; factory</span>)</span>;</span><br><span class="line">        </span><br><span class="line">	<span class="function">IAny <span class="title">Get</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>;</span><br><span class="line"></span><br><span class="line">	[<span class="meta">LuaIgnore</span>]</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Define</span>(<span class="params"><span class="built_in">string</span> macro</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>NativeChannel</code>中维护一个字典<code>factories</code>存储所有反射调用的类，维护一个列表<code>macros</code>存储所有在Lua层需要添加的宏定义。</p>
<ul>
<li>Register()</li>
</ul>
<p>提供在C#层注册Object的方法</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Register</span>(<span class="params"><span class="built_in">string</span> name, Func&lt;<span class="built_in">object</span>&gt; factory</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.factories.Add(name, () =&gt; <span class="keyword">new</span> AnyObject(factory()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Get()</li>
</ul>
<p>暴露到Lua层，供Lua层通过类名获取对应的引用，若字典中存在该类型则直接返回，若不存在则创建对应的Object。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IAny <span class="title">Get</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.factories.TryGetValue(name, <span class="keyword">out</span> <span class="keyword">var</span> factory))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> factory();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> type = Type.GetType(name);</span><br><span class="line">	<span class="keyword">if</span> (type == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (type.IsAbstract &amp;&amp; type.IsSealed)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> AnyStaticObject(type);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">var</span> obj = Activator.CreateInstance(type);</span><br><span class="line">		<span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> AnyObject(obj);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Define()</li>
</ul>
<p>在C#层中添加宏定义。</p>
<h4 id="三-问题与解决方法"><a href="#三-问题与解决方法" class="headerlink" title="三  问题与解决方法"></a>三  问题与解决方法</h4><h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><p>对于属性的赋值和方法的参数，Lua层传递过来的数据在C#中为Object类型，需要根据目标类型进行显式的转换。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">object</span> <span class="title">ConvertType</span>(<span class="params">Type type, <span class="built_in">object</span> <span class="keyword">value</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (type == <span class="keyword">typeof</span>(<span class="built_in">short</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> Convert.ToInt16(<span class="keyword">value</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="委托的调用"><a href="#委托的调用" class="headerlink" title="委托的调用"></a>委托的调用</h5><ul>
<li><p>为了能正确调用委托，需要确定委托的参数和类型，因此需要特别封装各种参数数量的泛型类<code>Handler</code>，每种<code>Handler</code>类包含构造方法<code>Handler()</code>和触发回调方法的函数<code>Handle()</code>。</p>
</li>
<li><p>在委托添加方法时，先获取方法所有的参数，根据参数个数和每个参数的类型确定<code>Handler</code>的类型：<code>type = typeof(Handler&lt;&gt;).MakeGenericType(args);</code>。</p>
</li>
<li><p>接着使用<code>var helper = Activator.CreateInstance(type, func, self);</code>构造实例。</p>
</li>
<li><p>最后绑定方法</p>
<p><code>var handler = Delegate.CreateDelegate(eventHandlerType, helper, &quot;Handle&quot;);
eventInfo.AddEventHandler(this.target, handler);</code></p>
<p>至此，当委托触发时，就能调用到对应<code>Handler</code>类中的<code>Handle()</code>方法，通过该方法再触发Lua层对应的方法，实现动态的绑定调用。</p>
</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Handler</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> funcName;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">readonly</span> LuaTable self;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">readonly</span> LuaFunction func;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Handler</span>(<span class="params"><span class="built_in">string</span> funcName, LuaTable self = <span class="literal">null</span></span>)</span></span><br><span class="line"><span class="function"></span>	&#123;</span><br><span class="line">		<span class="keyword">this</span>.funcName = funcName;</span><br><span class="line">		<span class="keyword">this</span>.self = self;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Handler</span>(<span class="params">LuaFunction func</span>)</span></span><br><span class="line"><span class="function"></span>	&#123;</span><br><span class="line">		<span class="keyword">this</span>.func = func;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span>(<span class="params">T1 a, T2 b</span>)</span></span><br><span class="line"><span class="function"></span>	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.func == <span class="literal">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (self == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">			<span class="keyword">if</span> (!(self[funcName] <span class="keyword">is</span> LuaFunction f)) <span class="keyword">return</span>;</span><br><span class="line">			f.Call(self, a, b);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			func.Call(a, b);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="IL2CPP裁剪代码问题"><a href="#IL2CPP裁剪代码问题" class="headerlink" title="IL2CPP裁剪代码问题"></a>IL2CPP裁剪代码问题</h5><ul>
<li><a href="[Unity - Manual: Managed code stripping (unity3d.com"><strong>什么是代码裁剪</strong></a>](<a href="https://docs.unity3d.com/Manual/ManagedCodeStripping.html">https://docs.unity3d.com/Manual/ManagedCodeStripping.html</a>))  当Unity中的Scripting Backend为IL2CPP时，默认会勾选代码裁剪，此时，构建时Unity代码裁剪工具会分析项目中的程序集，查找和删除未使用的代码，裁剪掉没有使用到的代码。</li>
<li><strong>带来问题</strong>  <a href="[IL2CPP Type.MakeGenericType work around - Unity Forum](https://forum.unity.com/threads/il2cpp-type-makegenerictype-work-around.311926/">参考Unity官方回答</a>) 问题主要出在<code>MakeGenericType()</code>方法上，该方法作用为：替代由当前泛型类型定义的类型参数组成的类型数组的元素，并返回表示结果构造类型的 Type 对象。目前IL2CPP还没有完全支持该方法，只能处理代码中已有的类型。</li>
<li><strong>解决方法</strong>  可以通过在代码中明确声明需要使用到的类型来规避这一问题。额外定义特性用于修饰委托。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Delegate)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NativeHandle</span> : <span class="title">Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">NativeHandle</span>(<span class="params">Type type</span>)</span></span><br><span class="line"><span class="function"></span>	&#123;</span><br><span class="line">		<span class="keyword">this</span>.Type = type;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Type Type &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125; = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">NativeHandle(typeof(Handler&lt;int&gt;))</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">InitCompleteHandler</span>(<span class="params"><span class="built_in">int</span> retCode</span>)</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Lua</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>几种高级随机技术</title>
    <url>/2022/01/24/tech/Random/</url>
    <content><![CDATA[<h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>游戏开发中随机是一个常用的工具，游戏程序员需要常常和<code>rand()</code>函数打交道，但是很多效果其实是无法通过简单的<code>rand()</code>函数实现的，需要更高级的随机技术。以下简单整理了《游戏人工智能》《代码本色》中介绍的几种高级随机技术，主要有：</p>
<ul>
<li>高斯随机</li>
<li>随机值筛选</li>
<li>自定义分布的随机数</li>
<li>柏林噪声</li>
</ul>
<span id="more"></span>
<h3 id="二、高斯随机"><a href="#二、高斯随机" class="headerlink" title="二、高斯随机"></a>二、高斯随机</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>日常生活中许多现象在统计学上都满足高斯分布（即正态分布），其原因可以用<a href="https://zhuanlan.zhihu.com/p/25241653">中央极限定理</a>来解释。在游戏中为了达到更真实更贴近自然的模拟，也要采用高斯随机，而不是简单的均匀随机。</p>
<p><img data-src="/image/17-1.png" alt=" " style="zoom:100%;"/></p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>生成高斯随机值的方法非常简单，只需要对三个均匀随机值求和，即可得到一组满足高斯分布的随机数。<strong>更准确地说，按照中央极限定理，对多个[-1, 1]范围内的均匀随机数求和，其结果会逼近均值为0、标准差为$\sqrt{K/3}$ 的高斯分布，其中<em>K</em>为参与求和的随机数数量。</strong>如果<em>K</em>值为3，则标准差等于1，那么我们就得到一个标准正态分布。</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>高斯随机可以在游戏中得到广泛的应用，如：</p>
<ul>
<li>模拟弹道</li>
<li>NPC的平均或最大速度</li>
<li>NPC的反应时间</li>
<li>暴击概率</li>
<li>体型大小、宽度、高度、质量等</li>
</ul>
<p>为了达到更贴近真实的模拟，还可以进行叠加，如让每个NPC的基础射速呈高斯分布，而每一次射击还会在基础射速上按照高斯分布随机变化，这样就能达到非常自然的群体运动表现。</p>
<h3 id="三、自定义分布的随机数"><a href="#三、自定义分布的随机数" class="headerlink" title="三、自定义分布的随机数"></a>三、自定义分布的随机数</h3><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><p>现实中还存在许多例子不能用均匀分布或是高斯分布模拟，需要满足各种不同类型的分布，如指数分布、泊松分布、瑞利分布等。举个简单的例子：我们需要从[0, 1]中选出一个数，且数字越大，被选到的概率也越大，若选中概率为y，选中的值为x，可以简单地定义其映射关系为$y=x$。</p>
<p><img data-src="/image/17-2.png" alt=" " style="zoom:100%;"/></p>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>自定义分布的随机数的生成有几种不同的方法，可以参考<a href="https://www.cnblogs.com/xingshansi/p/6539319.html">信号处理——生成给定分布随机数</a>，这里介绍一种常见的方法：舍选法。</p>
<p><strong>每次生成两个随机数，第一个是普通随机数，第二个作为“资格随机数”，用来决定第一个随机数的取舍。</strong>对于以上举的例子，具体计算步骤如下：</p>
<ul>
<li>生成一个随机数R1 = 0.3</li>
<li>计算R1被选中的资格概率为0.3</li>
<li>生成另一个随机数R2</li>
<li>若R2 &lt; R1，则R1就是我们要的随机数</li>
<li>否则，回到第一步重新开始</li>
</ul>
<h3 id="四、随机值筛选"><a href="#四、随机值筛选" class="headerlink" title="四、随机值筛选"></a>四、随机值筛选</h3><h4 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h4><p>在游戏中，随机值过于随机也会存在问题，人们会认为少量的随机值不是随机生成的，比如游戏战斗中，敌方连续多次的暴击是完全有可能发生的，但对于玩家来说这样的体验就会很糟糕，甚至会开始怀疑游戏的机制或是作弊问题，因此作为开发者需要避免这样的情况产生，即让随机数序列<strong>看上去更随机</strong>。</p>
<h4 id="应对策略"><a href="#应对策略" class="headerlink" title="应对策略"></a>应对策略</h4><p>我们需要牺牲一点点随机完整性，换取一个看上去更加随机的序列。<strong>具体策略为：当生成一个随机数序列时，如果生成的下一个数会破坏随机性的表现，那就舍弃这个数然后再生成一个。</strong>具体策略可以参考《游戏人工智能：高级随机技术》，书中对于不同的情形有具体的应对策略。</p>
<p>值得注意的是，使用的筛选规则会影响到随机值的数学完整性，开源程序ENT提供了许多不同的度量标准来评估随机性。</p>
<h3 id="五、柏林噪声"><a href="#五、柏林噪声" class="headerlink" title="五、柏林噪声"></a>五、柏林噪声</h3><h4 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h4><p>游戏中会存在另一类随机需求：需要随机数之间存在连续性，即连续生成的随机数之间是有联系的，这种特性意味着我们不会在得到一个随机数之后得到一个差异很大的随机数。柏林噪声在图形学中有着广泛的应用，如用于生成大理石纹理、烟雾云彩、火焰等。</p>
<p><img data-src="/image/17-3.png" alt=" " style="zoom:100%;"/></p>
<p>在游戏AI方面，柏林噪声可以控制角色在一段时间内的移动或属性变化，如：</p>
<ul>
<li>角色移动（方向、速度、加速度）</li>
<li>精准度（连续的成功或失败，模拟运气势头）</li>
<li>注意力（警惕程度、反应时间）</li>
<li>角色情绪（冷静、愤怒、高兴、悲伤…）</li>
</ul>
<h4 id="一维柏林噪声的生成"><a href="#一维柏林噪声的生成" class="headerlink" title="一维柏林噪声的生成"></a>一维柏林噪声的生成</h4><ul>
<li>首先确定<strong>频程</strong>，每阶频程在特定层次上影响信号细节，引入更高的频程可以增加更细粒度的信息，每阶频程独立计算，累加后得到最终的信号。</li>
<li>第一阶频程首先在[0, 1]范围内随机生成信号的起始和结束值，然后对这两个值做插值计算，得到中间值，理想的<strong>插值函数为$6t^5-15t^4+10t^3$</strong>，该函数在0和1处一阶导和二阶导都为0，即在过渡处会非常平滑。</li>
<li>对于N阶频程，选取$2^{n-1}+1$个均匀随机数并等距离放置，然后再对其进行插值。</li>
<li>对于每一阶的信号，还需要乘以一个放大倍数$p^i$，其中<em>p</em>为顽固指数，<em>i</em>为频程的阶数。对所有的信号叠加后就得到了最终的柏林噪声。下图中的例子就是一个阶数为4，顽固指数为0.5的柏林噪声生成过程。</li>
</ul>
<p><img data-src="/image/17-4.png" alt=" " style="zoom:100%;"/></p>
<p>回顾以上的生成过程我们可以从中提取出几个重要的参数，通过改变他们的大小就能生成不同样式的柏林噪声。</p>
<ul>
<li><strong>频程的阶数</strong>：低阶频程在最终信号中造成更大的波动，而高阶的频程则导致更细粒度的噪声。</li>
<li><strong>频程的范围</strong>：可以任意指定信号的频程范围来生成不同的最终信号。</li>
<li><strong>每阶频程的放大倍数</strong>：可以通过改变每阶频程的放大倍数来决定该频程在最终信号中的权重。</li>
<li><strong>插值函数的选择</strong>：$6t^5-15t^4+10t^3$为常用的插值函数，但也可以选择不同的插值函数来达到一些有趣的效果。</li>
</ul>
<p>以上介绍一维柏林噪声的生成，但在图形学中用的更多的是二维柏林噪声，关于二维噪声的生成或是其他种类的噪声可以阅读<a href="https://blog.csdn.net/candycat1992/article/details/50346469">【图形学】谈谈噪声</a></p>
<p><strong>参考资料：</strong></p>
<ul>
<li>《游戏人工智能》第一部分3</li>
<li>《代码本色》第一章：引言</li>
<li><a href="https://zhuanlan.zhihu.com/p/25241653">中心极限定理通俗介绍 - 知乎</a></li>
<li><a href="https://www.cnblogs.com/xingshansi/p/6539319.html">信号处理——生成给定分布随机数</a></li>
<li><a href="https://blog.csdn.net/candycat1992/article/details/50346469">【图形学】谈谈噪声</a></li>
</ul>
]]></content>
      <tags>
        <tag>随机</tag>
      </tags>
  </entry>
  <entry>
    <title>状态模式和职责链模式</title>
    <url>/2021/05/20/tech/StateAndDuty/</url>
    <content><![CDATA[<h3 id="故事背景"><a href="#故事背景" class="headerlink" title="故事背景"></a>故事背景</h3><p>最近在项目中负责任务系统相关的内容，刚重写了整个任务系统，趁热对过程中的心得做一点总结。</p>
<h3 id="原任务系统——状态模式"><a href="#原任务系统——状态模式" class="headerlink" title="原任务系统——状态模式"></a>原任务系统——状态模式</h3><p>原来的任务系统是一个多层状态机，第一层控制不同大类任务之间的切换（如主线任务、分支任务），第二层控制不同种类任务之间的切换（如刷怪任务、剧情任务），第三层控制一个任务下不同行为状态之间的切换（如跑到某地、刷怪、对话等行为）。三层状态机中，中间层使用了状态模式实现，其余两层使用判断进行状态切换。在游戏设计之初，这种设计方法可能可以满足策划的需求，但随着需求的增多，问题就逐渐暴露出来，大致可以总结出几个问题：</p>
<span id="more"></span>
<ul>
<li><strong>代码冗余，可读性差：</strong>在不同种类的任务中可能会存在相同的行为，如刷怪任务和NPC对话任务都有跑到指定地点的行为，为了能让代码复用，这些公共的行为就被提出来写在了Manager中供状态调用，但是在不同任务中，执行完该行为后切换的下一个行为又是不同的，因此在行为的方法中又需要对当前行为进行判断。整体上来看，表示不同种类任务的状态类中只有状态的切换，具体的逻辑都在Manager中，使得Manager类十分庞杂，阅读时需要在状态类和Manager之间来回切换，不是非常直观。</li>
<li><strong>灵活性差、无法应对多变的需求：</strong>这一点是状态模式本身的特点导致的，状态模式在类的设计中就确定了状态之间的转换，其转换关系是确定的，规范的状态模式客户都不知道状态之间的切换的结构，这样的设计非常稳定，但缺点就是灵活性差，耦合度高。但在游戏制作过程中，任务相关的需求总是多变的，比如策划突然想在前往某地和刷怪之间增加一个播放Timeline的环节，那么使用状态模式设计的任务系统就需要添加一个名为播放Timeline的状态，需要在原前往某地的状态切换中将下一个状态从刷怪改为播放Timeline，这就违反了设计原则中的<strong>开闭原则</strong>。</li>
</ul>
<h3 id="新任务系统——职责链模式"><a href="#新任务系统——职责链模式" class="headerlink" title="新任务系统——职责链模式"></a>新任务系统——职责链模式</h3><p>在设计新任务系统时，考虑到一个任务中的步骤可能会经常变化，因此需要使用更加灵活的设计模式来应对变化。新的系统主体采用职责链模式，定义好各种事件，每个事件中处理进入事件、更新事件、退出事件等方法，在执行一个任务前，根据策划的配置从事件库中取出需要执行的事件包装成事件链，这一事件链就构成了这一个任务的整体流程，接着就只需要按照顺序依次触发事件的执行。这样设计的优点在于：</p>
<ul>
<li><strong>减少判断，流程更清晰：</strong>职责链模式在环境类中就组装好事件序列，在具体的事件类中，不需要知道后续的事件做什么，减少if-else判断，只需要维护<code>Execute()</code> <code>Update()</code> <code>OnFinish()</code>等方法，更加纯粹。</li>
<li><strong>灵活性高，使策划能够随意调整任务流程。</strong></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>状态模式适用于状态间的切换关系确定且不是很复杂的情况，也适用于一些需要根据用户输入改变状态的情况，其本质相当于if-else。</li>
<li>职责链模式适合事件执行顺序复杂多变，但执行开始之前事件序列已经确定的情况，其本质相当于switch-case。</li>
</ul>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>图的最短路径算法——SPFA</title>
    <url>/2021/12/23/tech/SPFA/</url>
    <content><![CDATA[<ul>
<li><p><a href="/2021/12/11/tech/Graph/index.html">图的基本概念</a></p>
</li>
<li><p><a href="/2021/12/12/tech/GraphSearch/index.html">图的盲目搜索</a></p>
</li>
<li><a href="/2021/12/13/tech/DijkstraAndAStar/index.html">图的最短路径算法——Dijkstra和A*</a></li>
</ul>
<h3 id="一、最短路径问题"><a href="#一、最短路径问题" class="headerlink" title="一、最短路径问题"></a>一、最短路径问题</h3><p>最短路径问题是一个基于开销的图搜索问题，指求解从图中的某一节点出发到达另一个节点经过所有边的开销和最小的路径。解决该问题的算法有：</p>
<ul>
<li>Dijkstra算法</li>
<li>A*算法</li>
<li>SPFA算法</li>
<li>Floyd算法</li>
</ul>
<span id="more"></span>
<h3 id="二、SPFA"><a href="#二、SPFA" class="headerlink" title="二、SPFA"></a>二、SPFA</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>和Dijkstra算法一样，SPFA也是用于解决图的<strong>单源最短路径问题</strong>，它是Bellman-Ford算法的改良版本。相比于Dijkstra算法，其优点是<strong>可以处理权值为负的图</strong>，缺点是<strong>时间复杂度比Dijkstra高，高达O(VE)。</strong></p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul>
<li><p>和Dijkstra类似，首先我们需要记录已经找到最短路径的节点以及待优化的节点。</p>
</li>
<li><p>不同点在于，Dijkstra算法运用了贪心的思想，每次从待优化节点中取出开销最小的节点，进入下一次循环；<strong>而SPFA算法采用的是动态规划的思想，使用一个队列保存待优化的节点，每一次循环取出队首节点P，并对该节点相邻的节点进行松弛操作，对于某一个相邻节点Q，若进行了松弛，且P不在队列中，则P节点会加入到队列中。这样不断循环直至队列为空。</strong></p>
</li>
<li>需要注意的是若图中存在负环，则算法会进入死循环，因此需要对负环进行判断，只需要记录每个点进入队列的次数，若次数超过图的顶点数，则存在负环。</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">SPFA</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title">Distance</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">float</span> <span class="keyword">value</span> = <span class="built_in">float</span>.MaxValue;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> times;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">List</span>&lt;<span class="title">Node</span>&lt;<span class="title">T</span>&gt;&gt; path</span> = <span class="keyword">new</span> List&lt;Node&lt;T&gt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Node&lt;T&gt;&gt; SPFASearch(Graph&lt;T&gt; graph, Node&lt;T&gt; start, Node&lt;T&gt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (graph == <span class="literal">null</span> || start == <span class="literal">null</span> || !graph.IsNode(start)) <span class="keyword">return</span> <span class="keyword">new</span> List&lt;Node&lt;T&gt;&gt;();</span><br><span class="line">        Dictionary&lt;Node&lt;T&gt;, Distance&gt; dis = <span class="keyword">new</span> Dictionary&lt;Node&lt;T&gt;, Distance&gt;();</span><br><span class="line">        Queue&lt;Node&lt;T&gt;&gt; queue = <span class="keyword">new</span> Queue&lt;Node&lt;T&gt;&gt;();</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> vn <span class="keyword">in</span> graph)</span><br><span class="line">        &#123;</span><br><span class="line">            dis[vn.Data] = <span class="keyword">new</span> Distance();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dis[start].<span class="keyword">value</span> = <span class="number">0</span>;</span><br><span class="line">        dis[start].times++;</span><br><span class="line">        queue.Enqueue(start);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (queue.Count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Node&lt;T&gt; fNode = queue.Dequeue();</span><br><span class="line">            <span class="keyword">var</span> adjNode = graph[fNode].FirstAdjNode;</span><br><span class="line">            <span class="keyword">while</span> (adjNode != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> d = dis[adjNode.Data];</span><br><span class="line">                <span class="keyword">if</span> (adjNode.Cost + dis[fNode].<span class="keyword">value</span> &lt; d.<span class="keyword">value</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    d.<span class="keyword">value</span> = adjNode.Cost + dis[fNode].<span class="keyword">value</span>;</span><br><span class="line">                    d.path = <span class="keyword">new</span> List&lt;Node&lt;T&gt;&gt;(dis[fNode].path) &#123;fNode&#125;;</span><br><span class="line">                    <span class="keyword">if</span> (!queue.Contains(adjNode.Data))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (dis[adjNode.Data].times &gt; graph.NodeNum)</span><br><span class="line">                        &#123;</span><br><span class="line">                            Debug.LogError(<span class="string">&quot;图中存在负环，无最短路径！&quot;</span>);</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">new</span> List&lt;Node&lt;T&gt;&gt;();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        dis[adjNode.Data].times++;</span><br><span class="line">                        queue.Enqueue(adjNode.Data);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                adjNode = adjNode.Next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dis[end].path.Count &gt; <span class="number">0</span>) dis[end].path.Add(end);</span><br><span class="line">        <span class="keyword">return</span> dis[end].path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>和Dijkstra算法类似，我们优化的切入点也是待优化节点的数据结构，在Dijkstra算法中我们采用优先队列进行优化，而SPFA也可以用类似的思想来提高队列中节点排列的质量，从而提升平均性能（无法提升最坏情况下的性能），<strong>优化方法主要有SLF和LLL，都是通过调整队列中元素的顺序使得更靠近源节点的节点能够被更早地处理，两种方法可以结合。</strong></p>
<h5 id="SLF-Small-Label-First"><a href="#SLF-Small-Label-First" class="headerlink" title="SLF (Small Label First)"></a>SLF (Small Label First)</h5><p>此优化针对队列加入节点时。使用双端队列实现，在节点加入队列时，判断待加入节点和队首节点的路径开销，若待加入节点的路径开销较小，则加入到队首，否则加入到队尾。</p>
<h5 id="LLL-Large-Label-Last"><a href="#LLL-Large-Label-Last" class="headerlink" title="LLL(Large Label Last)"></a>LLL(Large Label Last)</h5><p>此优化针对的则是节点出队时，出队时需要比较队首节点的路径开销和队列中所有节点的路径开销平均值，若小于则正常出队，否则将出队节点加入到队尾，继续判断下一个队首节点，直到找到符合条件的节点。</p>
<h5 id="DFS优化"><a href="#DFS优化" class="headerlink" title="DFS优化"></a>DFS优化</h5><p>DFS优化主要在找负环上有优势，由于原始算法使用的是BFS的思想，不会在某一条路径上持续深入，因此需要当一个节点被加入队列N(节点总是)次后才知道图中存在负环，而DFS只需要一个节点出现两次以上，就知道存在负环，因此可以避免大量的遍历。</p>
<p><strong>参考资料：</strong></p>
<ul>
<li><a href="https://blog.csdn.net/qq_35644234/article/details/61614581">最短路径问题—-SPFA算法详解</a></li>
<li><a href="https://www.cnblogs.com/lfri/p/9521271.html">Bellman-Ford与SPFA </a></li>
</ul>
<p><strong>Demo地址：</strong><a href="https://github.com/Luciano-0/Graph.git">https://github.com/Luciano-0/Graph.git</a></p>
]]></content>
      <tags>
        <tag>Graph</tag>
        <tag>寻路</tag>
        <tag>SPFA</tag>
      </tags>
  </entry>
  <entry>
    <title>TimeLine自定义轨道</title>
    <url>/2021/01/24/tech/TimeLine1/</url>
    <content><![CDATA[<p>Unity中的TimeLine支持自定义轨道，一般需要新建三个（若需要处理混合则为四个）类。<a href="https://www.bilibili.com/video/BV1x7411P7J3">官方教学视频</a></p>
<span id="more"></span>
<h3 id="一、Track"><a href="#一、Track" class="headerlink" title="一、Track"></a>一、Track</h3><h4 id="1、用途"><a href="#1、用途" class="headerlink" title="1、用途"></a>1、用途</h4><p>首先需要定义一个轨道类，继承TrackAsset，它代表了时间轴内的轨道。<a href="https://docs.unity3d.com/cn/2018.1/ScriptReference/Timeline.TrackAsset.html">官方API</a></p>
<h4 id="2、代码示例"><a href="#2、代码示例" class="headerlink" title="2、代码示例"></a>2、代码示例</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">TrackColor(0.055f, 0.03f, 0.387f)</span>]</span><br><span class="line">[<span class="meta">TrackClipType(typeof(MyClip))</span>]</span><br><span class="line">[<span class="meta">TrackBindingType(typeof(Animator))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyTrack</span> : <span class="title">TrackAsset</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="built_in">int</span> blendingDuration = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> Playable <span class="title">CreatePlayable</span>(<span class="params">PlayableGraph graph, GameObject gameObject, TimelineClip clip</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> asset = clip.asset <span class="keyword">as</span> MyClip;</span><br><span class="line">        asset.duration = blendingDuration;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">base</span>.CreatePlayable(graph, gameObject, clip);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、轨道类可以被三种特性标签修饰"><a href="#3、轨道类可以被三种特性标签修饰" class="headerlink" title="3、轨道类可以被三种特性标签修饰"></a>3、轨道类可以被三种特性标签修饰</h4><ul>
<li><code>[TrackColor(float r, float g, float b)]</code>用于定义轨道的颜色，方便不同轨道之间的区分；</li>
<li><code>[TrackClipType(Type clipClass)]</code>用于指定在轨道中可创建的<code>PlayableAsset</code>类型，可以理解实现了轨道类型和片段类型之间的绑定，同一个轨道可以添加多种不同的片段类型，及可以有多个<code>TrackClipType</code>修饰同一个轨道类；</li>
<li><code>[TrackBindingType(Type type)]</code>用于指定轨道需要绑定到的对象类型，如示例中的<code>LookAtTrack</code>是用于控制某个角色上的头部动画，因此需要绑定一个角色的Animator组件。若改轨道不需要绑定特定对象，则不需要添加该标签。</li>
</ul>
<h4 id="4、常用方法"><a href="#4、常用方法" class="headerlink" title="4、常用方法"></a>4、常用方法</h4><ul>
<li><code>protected override Playable CreatePlayable(PlayableGraph graph, GameObject gameObject, TimelineClip clip)</code></li>
<li><code>protected override void OnCreateClip(TimelineClip clip)</code> 在新建片段时调用用于设置Clip的默认值。</li>
<li><code>public override Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount)</code>当片段之间支持混合时可添加该方法。</li>
</ul>
<h3 id="二、Asset"><a href="#二、Asset" class="headerlink" title="二、Asset"></a>二、Asset</h3><h4 id="1、用途-1"><a href="#1、用途-1" class="headerlink" title="1、用途"></a>1、用途</h4><p>接着定义一个继承<code>PlayableAsset</code>、实现接口<code>ITimelineClipAsset</code>的类，用于表示片段资源，该类中可以定义片段包含的字段，这些字段会暴露到Inspector中。</p>
<h4 id="2、代码示例-1"><a href="#2、代码示例-1" class="headerlink" title="2、代码示例"></a>2、代码示例</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClip</span> : <span class="title">PlayableAsset</span>, <span class="title">ITimelineClipAsset</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">string</span> content;</span><br><span class="line">	<span class="keyword">public</span> ExposedReference&lt;Transform&gt; target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> DialogueBehaviour template = <span class="keyword">new</span> MyBehaviour();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ClipCaps clipCaps</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">get</span> &#123; <span class="keyword">return</span> ClipCaps.None; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Playable <span class="title">CreatePlayable</span>(<span class="params">PlayableGraph graph, GameObject owner</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">		<span class="keyword">var</span> playable = ScriptPlayable&lt;MyBehaviour&gt;.Create(graph, template);</span><br><span class="line">		<span class="keyword">var</span> myBehaviour = playable.GetBehaviour();</span><br><span class="line">		myBehaviour.content = content;</span><br><span class="line">		myBehaviour.target = target;</span><br><span class="line">		<span class="keyword">return</span> playable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、常用方法"><a href="#3、常用方法" class="headerlink" title="3、常用方法"></a>3、常用方法</h4><p>通常该类中会重写<code>CreatePlayable()</code>方法，常用于实现该类和<code>Behaviour</code>类之间的数据传递，关于</p>
<p>ScriptPlayable 和 PlayableBehaviour的使用可参考<a href="https://docs.unity3d.com/cn/current/Manual/Playables-ScriptPlayable.html">ScriptPlayable 和 PlayableBehaviour - Unity 手册 </a></p>
<h3 id="三、Behaviour"><a href="#三、Behaviour" class="headerlink" title="三、Behaviour"></a>三、Behaviour</h3><h4 id="1、用途-2"><a href="#1、用途-2" class="headerlink" title="1、用途"></a>1、用途</h4><p>接着定义一个Behaviour类继承<code>PlayableBehaviour</code>用于描述片段中触发的行为。<a href="https://docs.unity3d.com/2017.1/Documentation/ScriptReference/Playables.PlayableBehaviour.html">官方API</a></p>
<h4 id="2、代码示例-2"><a href="#2、代码示例-2" class="headerlink" title="2、代码示例"></a>2、代码示例</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyBehaviour</span> : <span class="title">PlayableBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> clipPlayed = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> pauseScheduled = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> PlayableDirector director;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnPlayableCreate</span>(<span class="params">Playable playable</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        director = (playable.GetGraph().GetResolver() <span class="keyword">as</span> PlayableDirector);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnBehaviourPlay</span>(<span class="params">Playable playable, FrameData info</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!clipPlayed &amp;&amp; info.weight &gt; <span class="number">0f</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Application.isPlaying) pauseScheduled = <span class="literal">true</span>;</span><br><span class="line">            clipPlayed = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnBehaviourPause</span>(<span class="params">Playable playable, FrameData info</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pauseScheduled)</span><br><span class="line">        &#123;</span><br><span class="line">            pauseScheduled = <span class="literal">false</span>;</span><br><span class="line">            clipPlayed = <span class="literal">false</span>;</span><br><span class="line">            director.Pause();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、常用方法-1"><a href="#3、常用方法-1" class="headerlink" title="3、常用方法"></a>3、常用方法</h4><ul>
<li><code>PrepareFrame</code> 循环播放刷新时调用</li>
<li><code>OnBehaviourPlay</code> 进入该行为片段时调用</li>
<li><code>OnBehaviourPause</code> 退出该行为片段时调用</li>
<li><code>OnPlayableCreate</code> 创建时、编辑器模式选中Timeline时</li>
<li><code>OnGraphStart</code> 创建后、播放时</li>
<li><code>OnGraphStop</code> 停止时，编辑器模式选中其他对象时</li>
<li><code>OnPlayableDestroy</code> 同上，在停止后调用</li>
</ul>
<h3 id="四、Mixer"><a href="#四、Mixer" class="headerlink" title="四、Mixer"></a>四、Mixer</h3><p>若需要使轨道片段支持融合，则需要添加Mixer类，该类同样继承<code>PlayableBehaviour</code></p>
<h3 id="五、踩坑合集"><a href="#五、踩坑合集" class="headerlink" title="五、踩坑合集"></a>五、踩坑合集</h3><ul>
<li>Clip的遍历：Timeline没有提供快速定位到某一Clip的接口，要想定位只能遍历，而且要从轨道开始遍历，这让代码写起来非常恶心，需要嵌套多层循环。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">IEnumerable&lt;TimelineClip&gt; tempClips = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> playableAsset = director.playableAsset <span class="keyword">as</span> TimelineAsset;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> track <span class="keyword">in</span> playableAsset.GetOutputTracks())</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (track <span class="keyword">is</span> MyTrack &amp;&amp; !track.muted)</span><br><span class="line">	&#123;</span><br><span class="line">		tempClips = track.GetClips();</span><br><span class="line">		<span class="keyword">foreach</span> (<span class="keyword">var</span> clip <span class="keyword">in</span> tempClips)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (clip.asset <span class="keyword">is</span> MyClip b)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//...</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对场景中对象的引用需要通过<code>ExposedReference&lt;T&gt;</code>创建，否则绑定完成的引用无法被Unity保存。对应的调用则需要通过<code>Resolve(graph.GetResolver())</code>解析出对象。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ExposedReference&lt;Transform&gt; target;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Playable <span class="title">CreatePlayable</span>(<span class="params">PlayableGraph graph, GameObject owner</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> target = target.Resolve(graph.GetResolver());    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C#</tag>
        <tag>Unity</tag>
        <tag>Timeline</tag>
      </tags>
  </entry>
  <entry>
    <title>一种拨轮动效</title>
    <url>/2020/09/28/tech/TimeWidget/</url>
    <content><![CDATA[<p>实现了一种拨轮动画效果，可以用于游戏中的倒计时、数值显示等。目前实现了初始化的动画效果。</p>
<span id="more"></span>
<video src="/image/TimeWidget.mp4" controls="controls" style="max-width: 80%; display: block; margin-left: auto; margin-right: auto;"> your browser does not support the video tag </video>

<p><a href="https://github.com/Luciano-0/TimeWidget">Github地址</a></p>
]]></content>
      <tags>
        <tag>C#</tag>
        <tag>Unity</tag>
        <tag>动效</tag>
      </tags>
  </entry>
  <entry>
    <title>Timeline跳转过渡</title>
    <url>/2021/01/30/tech/Timeline2/</url>
    <content><![CDATA[<h3 id="一、Animation-Track的过渡"><a href="#一、Animation-Track的过渡" class="headerlink" title="一、Animation Track的过渡"></a>一、Animation Track的过渡</h3><h4 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h4><p>当运行到Clip中间时，角色动画会由Timeline接管，即播放AnimationClip中的动画，当运行到Clip之外时，若前后片段中的Animation Extrapolation有设置为Hold，则会保持对应帧的动作，若都为None则会将动画控制权移交给状态机，通常播放Idle的动作。</p>
<span id="more"></span>
<h4 id="2、问题"><a href="#2、问题" class="headerlink" title="2、问题"></a>2、问题</h4><p>通常在游戏的剧情对话中，用户点击可以跳转到下一段对话，此时会涉及到两个AnimationClip之间的跳转过渡，若直接跳转则会出现动作的突变，即上一动画还没有播放完，就会切到下一动画的开头，影响观感。因此需要进行过渡处理。</p>
<h4 id="3、解决方法"><a href="#3、解决方法" class="headerlink" title="3、解决方法"></a>3、解决方法</h4><p>要想实现自然的过渡就需要两个Clip之间的融合，目前实现的方案是在跳转时对未播放完的片段进行克隆，将其移到下一个片段的开头，Timeline就会对两个片段自动融合。需要注意的是，运行时克隆出来的片段在运行完后Timeline不会对其销毁，因此需要将这些克隆片段暂存起来，在合适的时候删除。</p>
<h4 id="4、代码"><a href="#4、代码" class="headerlink" title="4、代码"></a>4、代码</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AnimationTranstion</span>(<span class="params"><span class="built_in">int</span> to</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DeleteCloneClip(cloneAnimationClips);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> track <span class="keyword">in</span> animationClips)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!track.Value.TryGetValue(curSectionClip, <span class="keyword">out</span> _)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!cloneAnimationClips.TryGetValue(track.Key, <span class="keyword">out</span> _))</span><br><span class="line">            cloneAnimationClips[track.Key] = <span class="keyword">new</span> List&lt;TimelineClip&gt;();</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> clip <span class="keyword">in</span> track.Value[curSectionClip])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (clip.start &lt; director.time &amp;&amp; clip.end &gt; director.time)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> cloneClip = CloneTimelineAnimationClip(track.Key <span class="keyword">as</span> AnimationTrack, clip);</span><br><span class="line"></span><br><span class="line">                cloneClip.start = sectionClips[to].start - (director.time - clip.start);</span><br><span class="line">                TimelineClip nextClip = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    nextClip = animationClips[track.Key][sectionClips[to]][<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                catch (Exception e)</span><br><span class="line">                &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nextClip != <span class="literal">null</span> &amp;&amp; nextClip.start - sectionClips[to].start &lt;= clip.end - director.time)</span><br><span class="line">                    &#123;</span><br><span class="line">                        cloneClip.duration = director.time - clip.start + Mathf.Min(<span class="keyword">new</span>[]</span><br><span class="line">                        &#123;</span><br><span class="line">                            (<span class="built_in">float</span>) (clip.end - director.time),</span><br><span class="line">                            (<span class="built_in">float</span>) (nextClip.easeInDuration + nextClip.start - sectionClips[to].start)</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> cloneClip.duration = clip.duration;</span><br><span class="line"></span><br><span class="line">                    cloneAnimationClips[track.Key].Add(cloneClip);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> TimelineClip <span class="title">CloneTimelineAnimationClip</span>(<span class="params">AnimationTrack track, TimelineClip nativeClip</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cloneClip = track.CreateClip(nativeClip.animationClip);</span><br><span class="line">    cloneClip.start = nativeClip.start;</span><br><span class="line">    cloneClip.duration = nativeClip.duration;</span><br><span class="line">    cloneClip.easeInDuration = nativeClip.easeInDuration;</span><br><span class="line">    cloneClip.easeOutDuration = nativeClip.easeOutDuration;</span><br><span class="line">    cloneClip.clipIn = nativeClip.clipIn;</span><br><span class="line">    cloneClip.timeScale = nativeClip.timeScale;</span><br><span class="line">    cloneClip.blendInDuration = nativeClip.blendInDuration;</span><br><span class="line">    cloneClip.blendOutDuration = nativeClip.blendOutDuration;</span><br><span class="line">    cloneClip.blendInCurveMode = nativeClip.blendInCurveMode;</span><br><span class="line">    cloneClip.blendOutCurveMode = nativeClip.blendOutCurveMode;</span><br><span class="line">    <span class="keyword">return</span> cloneClip;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DeleteCloneClip</span>(<span class="params">Dictionary&lt;TrackAsset, List&lt;TimelineClip&gt;&gt; dictionary</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">foreach</span> (<span class="keyword">var</span> pair <span class="keyword">in</span> dictionary)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">foreach</span> (<span class="keyword">var</span> clip <span class="keyword">in</span> pair.Value)</span><br><span class="line">		&#123;</span><br><span class="line">			pair.Key.DeleteClip(clip);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	dictionary.Clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二、Cinemachine-Track的过渡"><a href="#二、Cinemachine-Track的过渡" class="headerlink" title="二、Cinemachine Track的过渡"></a>二、Cinemachine Track的过渡</h3><h4 id="1、问题背景"><a href="#1、问题背景" class="headerlink" title="1、问题背景"></a>1、问题背景</h4><p>和Animation Track略有不同的是，Cinemachine Track在Clip之外会自动将相机控制权交给优先级最高的虚拟相机。</p>
<p>当Clip存在渐变过渡时，实际上是将优先权最高的相机位置和Clip绑定的相机位置进行融合。</p>
<h4 id="2、解决方法"><a href="#2、解决方法" class="headerlink" title="2、解决方法"></a>2、解决方法</h4><p>添加一个虚拟相机，将优先级设置为最高，用于缓存真实相机的位置。在发生跳转时，将此时真实相机的位置状态赋给该虚拟相机。跳转后就是该虚拟相机与下一片段的虚拟相机进行融合。</p>
<h4 id="3、代码"><a href="#3、代码" class="headerlink" title="3、代码"></a>3、代码</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> CinemachineVirtualCamera cineMachine;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CinemachineTranstion</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (director == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">var</span> playableAsset = director.playableAsset <span class="keyword">as</span> TimelineAsset;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> track <span class="keyword">in</span> playableAsset.GetOutputTracks())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> binding = director.GetGenericBinding(track);</span><br><span class="line">        <span class="keyword">if</span> (!(track <span class="keyword">is</span> CinemachineTrack &amp;&amp; !track.muted &amp;&amp; binding != <span class="literal">null</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Camera camera = (binding <span class="keyword">as</span> CinemachineBrain).gameObject.GetComponent&lt;Camera&gt;();</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> clip <span class="keyword">in</span> track.GetClips())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (clip.start &lt;= director.time &amp;&amp; clip.end &gt;= director.time)</span><br><span class="line">            &#123;</span><br><span class="line">                cineMachine.transform.position = camera.transform.position;</span><br><span class="line">                cineMachine.transform.rotation = camera.transform.rotation;</span><br><span class="line">                cineMachine.transform.localScale = camera.transform.localScale;</span><br><span class="line">                LensSettings lens = cineMachine.State.Lens;</span><br><span class="line">                lens.OrthographicSize = camera.orthographicSize;</span><br><span class="line">                lens.NearClipPlane = camera.nearClipPlane;</span><br><span class="line">                lens.FarClipPlane = camera.farClipPlane;</span><br><span class="line">                lens.FieldOfView = camera.fieldOfView;</span><br><span class="line">                cineMachine.m_Lens = lens;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C#</tag>
        <tag>Unity</tag>
        <tag>Timeline</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/01/01/tech/hello-world/</url>
    <content><![CDATA[<p>Hello World！</p>
]]></content>
  </entry>
  <entry>
    <title>Anconda常用命令</title>
    <url>/2020/09/12/tech/text/</url>
    <content><![CDATA[<ul>
<li>conda当前版本</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda -V</span><br></pre></td></tr></table></figure>
<ul>
<li>列举当前安装的包</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda list</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<ul>
<li>conda基本信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda info</span><br></pre></td></tr></table></figure>
<ul>
<li>当前存在的虚拟环境</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda env list</span><br></pre></td></tr></table></figure>
<ul>
<li>检查更新</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda update conda</span><br></pre></td></tr></table></figure>
<ul>
<li>创建虚拟环境</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda create --name your_env_name python&#x3D;3.7</span><br></pre></td></tr></table></figure>
<ul>
<li>激活虚拟环境</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda activate your_env_name</span><br></pre></td></tr></table></figure>
<ul>
<li>关闭虚拟环境</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda deactivate</span><br></pre></td></tr></table></figure>
<ul>
<li>安装包</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda install package_name</span><br></pre></td></tr></table></figure>
<ul>
<li>删除包</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda remove package_name</span><br></pre></td></tr></table></figure>
<ul>
<li>删除虚拟环境</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda remove --name your_env_name --all</span><br></pre></td></tr></table></figure>
<ul>
<li>添加源</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda config --add channel_urls</span><br></pre></td></tr></table></figure>
<ul>
<li>换回默认源</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda config --remove-key channels</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>山河满目，既往不咎</title>
    <url>/2020/01/10/photo/20200110-WestLake/</url>
    <content><![CDATA[<p>2019年最后一天，于西湖。</p>
<p><img data-src="/image/6-1.jpg" alt=" " style="zoom:30%;"/></p>
<span id="more"></span>
<p><img data-src="/image/6-2.jpg" alt=" " style="zoom:30%;"/></p>
<p><img data-src="/image/6-3.jpg" alt=" " style="zoom:30%;"/></p>
<p><img data-src="/image/6-4.jpg" alt=" " style="zoom:30%;"/></p>
<p><img data-src="/image/6-5.jpg" alt=" " style="zoom:30%;"/></p>
<p><img data-src="/image/6-6.jpg" alt=" " style="zoom:30%;"/></p>
]]></content>
      <tags>
        <tag>photos</tag>
        <tag>胶片</tag>
      </tags>
  </entry>
  <entry>
    <title>关于校园的一些碎片</title>
    <url>/2020/01/01/photo/20200101-school/</url>
    <content><![CDATA[<p><img data-src="/image/4-1.jpg" alt="天台" style="zoom:16%;"/></p>
<span id="more"></span>
<p><img data-src="/image/4-2.jpg" alt="红黄蓝" style="zoom:30%;"/></p>
<p><img data-src="/image/4-4.jpg" alt="最爱玉泉午后的光影" style="zoom:30%;"/></p>
<p><img data-src="/image/4-5.jpg" alt="玉泉某个角落" style="zoom:30%;"/></p>
<p><img data-src="/image/4-6.jpg" alt="不知道是什么楼" style="zoom:30%;"/></p>
<p><img data-src="/image/4-7.jpg" alt="祖国万岁" style="zoom:30%;"/></p>
<p><img data-src="/image/4-8.jpg" alt="请爱护光缆" style="zoom:30%;"/></p>
<p><img data-src="/image/4-9.jpg" alt="紫金港的鹅鹅鹅" style="zoom:16%;"/></p>
<p><img data-src="/image/4-10.jpg" alt="你瞅啥" style="zoom:16%;"/></p>
]]></content>
      <tags>
        <tag>photos</tag>
        <tag>胶片</tag>
      </tags>
  </entry>
  <entry>
    <title>月亮碎了，于是星星亮了</title>
    <url>/2020/04/30/photo/20200430-star/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>手牵手一步两步三步四步望着天    </p>
<p>看星星一颗两颗三颗四颗连成线</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>
<p><img data-src= "/image/2-1.jpg" alt="1" style="zoom:16%;"/></p>
<span id="more"></span>
<p><img data-src= "/image/2-2.jpg" alt="2" style="zoom:16%;"/></p>
<p><img data-src= "/image/2-3.jpg" alt="3" style="zoom:16%;"/></p>
<p><img data-src= "/image/2-4.jpg" alt="4" style="zoom:16%;"/></p>
<p><img data-src= "/image/2-5.jpg" alt="5" style="zoom:16%;"/></p>
<p><img data-src= "/image/2-6.jpg" alt="6" style="zoom:16%;"/></p>
]]></content>
      <tags>
        <tag>photos</tag>
      </tags>
  </entry>
  <entry>
    <title>毕业那些事</title>
    <url>/2020/10/11/photo/20200630-graduate/</url>
    <content><![CDATA[<p>毕业，在杭州的雨季中悄然而至。</p>
<p>2020年的毕业季，号称史上最难毕业季。疫情之下，校园紧闭，连最后的相聚也显得格外仓促。</p>
<span id="more"></span>
<p>雨后的校园，就会长出三三两两的穿着学位服拍照的人们，趁着一两片弥足珍贵的阳光，定格校园中最后的时光。</p>
<p><img data-src="/image/1-1.jpg" alt="最后一课" style="zoom:16%;"/></p>
<p>平日里，我是一个没心没肺的人，但到了离别的时候，总想着，让时间过得再慢一些，还想和这些可爱的人儿多说一些话。</p>
<p>高中毕业时，似乎内心全乎是高考结束的欣喜，全然没有离别的伤感。大概是因为喜欢的人还在身边，要好的哥们还住对面，大家奔赴五湖四海，但我们来自同一个地方，相聚还容易。</p>
<p>但今时不同往日。或许是因为我们来自五湖四海，匆匆四年又即将奔赴五湖四海，又或许，是因为自己也即将离开熟悉的城市，成为异乡人。</p>
<p>在未来的某一刻，可能会突然意识到，有些人，此刻说了再见，这辈子就真的再也不见了。</p>
<p><img data-src="/image/1-2.jpg" alt="毕业前再去瞅瞅西湖" style="zoom:25%;"/></p>
<p>我们不能奢求有人可以一直陪我们走下去，有些人出现，就是在人生中陪我们走一段，这一段我们一起过得精彩，就足矣。<br>岁月匆匆，惟愿总相逢。</p>
]]></content>
      <tags>
        <tag>photos</tag>
      </tags>
  </entry>
  <entry>
    <title>故乡</title>
    <url>/2020/10/11/photo/20201005-hometown/</url>
    <content><![CDATA[<p>故乡，大概是写在每个人灵魂最深处的底层代码。</p>
<p>越长大，在家的日子就越少。曾经熟悉的地方，那些个常去的影院，洒过汗水的球场，躲过雨的屋檐，一不留神就变了模样，甚至，一晃眼就成了一片废墟，再也回不来了。</p>
<p>这小小的一方城池啊，承载着太多回忆。因为这片土地上有我们在意的人儿，发生过许许多多与我们有关的事，这土地上的钢筋混凝土才有了温度，被我们惦记着，并亲切地称之为故乡。</p>
<span id="more"></span>
<p><img data-src="/image/3-1.jpg" alt="1" style="zoom:30%;"/></p>
<p><img data-src="/image/3-2.jpg" alt="2" style="zoom:30%;"/></p>
<p><img data-src="/image/3-3.jpg" alt="3" style="zoom:30%;"/>    </p>
<p><img data-src="/image/3-4.jpg" alt="4" style="zoom:30%;"/></p>
<p><img data-src="/image/3-5.jpg" alt="5" style="zoom:30%;"/></p>
<p><img data-src="/image/3-6.jpg" alt="6" style="zoom:30%;"/></p>
<p><img data-src="/image/3-7.jpg" alt="7" style="zoom:30%;"/></p>
<p><img data-src="/image/3-8.jpg" alt="8" style="zoom:30%;"/></p>
]]></content>
      <tags>
        <tag>photos</tag>
        <tag>胶片</tag>
      </tags>
  </entry>
  <entry>
    <title>那些年追过的展（持续更新）</title>
    <url>/2020/10/31/photo/20201031-gallery/</url>
    <content><![CDATA[<p><img data-src="/image/5-1.jpg" alt="🌊" style="zoom:30%;"/></p>
<span id="more"></span>
<p><img data-src="/image/5-2.jpg" alt="早安打工人！" style="zoom:30%;"/></p>
<p><img data-src="/image/5-3.jpg" alt="西岸美术馆的长梯" style="zoom:30%;"/></p>
<p><img data-src="/image/5-4.jpg" alt="Wheel" style="zoom:30%;"/></p>
<p><img data-src="/image/5-5.jpg" alt="Plane" style="zoom:30%;"/></p>
<p><img data-src="/image/5-6.jpg" alt="月食" style="zoom:30%;"/></p>
<p><img data-src="/image/5-7.jpg" alt="最美二叉树？" style="zoom:30%;"/></p>
]]></content>
      <tags>
        <tag>photos</tag>
      </tags>
  </entry>
  <entry>
    <title>追夕阳的日子</title>
    <url>/2020/10/31/photo/20201031-sun/</url>
    <content><![CDATA[<p>秋分一过，白天以肉眼可见的速度缩短。平日里七点下班，只能和星星月亮打个照面。</p>
<p>可幸的是，今年的秋天格外长，西伯利亚的寒风迟迟没有吹来，好让我有足够多的时间去感受秋日午后的温柔。</p>
<p><img data-src="/image/7-1.jpg" alt=" " style="zoom:30%;"/></p>
<span id="more"></span>
<p>揣上相机，骑个单车，打开杰伦的歌单列表循环，去把陌生城市的大街小巷都溜达一遍。</p>
<p><img data-src="/image/7-2.jpg" alt=" " style="zoom:30%;"/></p>
<p>过了三点，太阳也开始打盹，像极了下班前提前开始摸鱼的我们。阳光渐渐向着长波段偏移，这时，情况就变得焦急起来。 光影瞬息万变， 每一次快门可不再像原来那么从容。</p>
<p><img data-src="/image/7-3.jpg" alt=" " style="zoom:40%;"/></p>
<p><img data-src="/image/7-4.jpg" alt=" " style="zoom:30%;"/></p>
<p>最后一缕阳光总是最珍贵的，向着西边的方向，以高中时赶早自习的速度，去追赶那一片在高楼间透出来的夕阳。不过，追不上也没有关系，看到那渐变的天空吗，那是老天爷对勤奋小孩额外的馈赠。</p>
<p><img data-src="/image/7-5.jpg" alt=" " style="zoom:30%;"/></p>
<p><img data-src="/image/7-6.jpg" alt=" " style="zoom:30%;"/></p>
<p>想起高中作文里常写的老套的句子：看日出日落，云卷云舒。没想到在退休前还有机会过一段这样的日子，没有眼前的苟且，也没有诗和远方。但我自由自在，做着自己喜欢的事，在进步的同时还能有时间可以浪费。</p>
<p><img data-src="/image/7-7.jpg" alt=" " style="zoom:30%;"/></p>
<p><img data-src="/image/7-8.jpg" alt=" " style="zoom:30%;"/></p>
<p>我永这会记得那个追着夕阳跑的少年，那份中二的浪漫，且珍惜。</p>
]]></content>
      <tags>
        <tag>photos</tag>
        <tag>胶片</tag>
      </tags>
  </entry>
  <entry>
    <title>下一站，南京东路站</title>
    <url>/2021/02/23/photo/20210223-TheBond/</url>
    <content><![CDATA[<p><img data-src="/image/8-1.jpg" alt=" " style="zoom:30%;"/></p>
<span id="more"></span>
<p><img data-src="/image/8-2.jpg" alt=" " style="zoom:30%;"/></p>
<p><img data-src="/image/8-3.jpg" alt=" " style="zoom:30%;"/></p>
<p><img data-src="/image/8-4.jpg" alt=" " style="zoom:30%;"/></p>
<p><img data-src="/image/8-5.jpg" alt=" " style="zoom:30%;"/></p>
<p><img data-src="/image/8-6.jpg" alt=" " style="zoom:30%;"/></p>
<p><img data-src="/image/8-7.jpg" alt=" " style="zoom:30%;"/></p>
<p><img data-src="/image/8-8.jpg" alt=" " style="zoom:30%;"/></p>
<p><img data-src="/image/8-9.jpg" alt=" " style="zoom:30%;"/></p>
<p><img data-src="/image/8-10.jpg" alt=" " style="zoom:30%;"/></p>
<p><img data-src="/image/8-11.jpg" alt=" " style="zoom:30%;"/></p>
<p><img data-src="/image/8-12.jpg" alt=" " style="zoom:30%;"/></p>
<p><img data-src="/image/8-13.jpg" alt=" " style="zoom:30%;"/></p>
]]></content>
      <tags>
        <tag>photos</tag>
        <tag>胶片</tag>
      </tags>
  </entry>
  <entry>
    <title>今日：阴有阵雨</title>
    <url>/2021/02/28/photo/20210228-RainyShangHai/</url>
    <content><![CDATA[<p><img data-src="/image/10-7.jpg" alt=" " style="zoom:30%;"/></p>
<span id="more"></span>
<p><img data-src="/image/10-1.JPG" alt=" " style="zoom:30%;"/></p>
<p><img data-src="/image/10-2.JPG" alt=" " style="zoom:30%;"/></p>
<p><img data-src="/image/10-3.jpg" alt=" " style="zoom:30%;"/></p>
<p><img data-src="/image/10-4.jpg" alt=" " style="zoom:30%;"/></p>
<p><img data-src="/image/10-5.jpg" alt=" " style="zoom:30%;"/></p>
<p><img data-src="/image/10-6.jpg" alt=" " style="zoom:30%;"/></p>
<p><img data-src="/image/10-8.jpg" alt=" " style="zoom:30%;"/></p>
<p><img data-src="/image/10-9.jpg" alt=" " style="zoom:30%;"/></p>
<p><img data-src="/image/10-10.jpg" alt=" " style="zoom:30%;"/></p>
<p><img data-src="/image/10-11.jpg" alt=" " style="zoom:30%;"/></p>
<p><img data-src="/image/10-12.jpg" alt=" " style="zoom:30%;"/></p>
]]></content>
      <tags>
        <tag>photos</tag>
      </tags>
  </entry>
  <entry>
    <title>避世岛屿——横沙</title>
    <url>/2021/04/05/photo/20210405-HengSha/</url>
    <content><![CDATA[<p><img data-src= "/image/11-1.jpg" alt="1" style="zoom:30%;"/></p>
<span id="more"></span>
<p><img data-src= "/image/11-2.jpg" alt="2" style="zoom:30%;"/></p>
<p><img data-src= "/image/11-3.jpg" alt="3" style="zoom:30%;"/></p>
<p><img data-src= "/image/11-4.jpg" alt="4" style="zoom:30%;"/></p>
<p><img data-src= "/image/11-5.jpg" alt="5" style="zoom:30%;"/></p>
<p><img data-src= "/image/11-6.jpg" alt="6" style="zoom:30%;"/></p>
<p><img data-src= "/image/11-7.jpg" alt="7" style="zoom:30%;"/></p>
<p><img data-src= "/image/11-8.jpg" alt="8" style="zoom:30%;"/></p>
<p><img data-src= "/image/11-9.jpg" alt="9" style="zoom:30%;"/></p>
<p><img data-src= "/image/11-10.jpg" alt="10" style="zoom:30%;"/></p>
]]></content>
      <tags>
        <tag>photos</tag>
      </tags>
  </entry>
  <entry>
    <title>有时也可以换个角度看世界</title>
    <url>/2021/04/20/photo/20210420-Dji/</url>
    <content><![CDATA[<p><img data-src= "/image/12-1.jpg" alt="第一次试飞" style="zoom:30%;"/></p>
<span id="more"></span>
<p><img data-src= "/image/12-2.jpg" alt="去了有名的“老法师桥”" style="zoom:30%;"/></p>
<p><img data-src= "/image/12-3.jpg" alt="第一次尝试黑金色调" style="zoom:30%;"/></p>
<p><img data-src= "/image/12-4.jpg" alt="还有冰蓝色调" style="zoom:30%;"/></p>
<p><img data-src= "/image/12-5.jpg" alt="空中俯瞰夜上海" style="zoom:30%;"/></p>
<p><img data-src= "/image/12-6.jpg" alt="第二次试飞" style="zoom:50%;"/></p>
<p><img data-src= "/image/12-7.jpg" alt="杨浦大桥" style="zoom:50%;"/></p>
<p><img data-src= "/image/12-8.jpg" alt="全景" style="zoom:50%;"/></p>
<p><img data-src= "/image/12-9.jpg" alt="熟悉的浦阳江" style="zoom:30%;"/></p>
<p><img data-src= "/image/12-10.jpg" alt="对岸的绿皮火车" style="zoom:30%;"/></p>
<p><img data-src= "/image/12-11.jpg" alt="不知通往何方" style="zoom:30%;"/></p>
<p><img data-src= "/image/12-12.jpg" alt="佘山" style="zoom:30%;"/></p>
<p><img data-src= "/image/12-13.jpg" alt="山顶的圣母教堂" style="zoom:30%;"/></p>
<p><img data-src= "/image/12-14.jpg" alt="日落时分" style="zoom:30%;"/></p>
<p><img data-src= "/image/12-15.jpg" alt="加一个胶片滤镜" style="zoom:30%;"/></p>
<p><img data-src= "/image/12-16.jpg" alt="喜欢宽幅带来的电影感" style="zoom:30%;"/></p>
]]></content>
      <tags>
        <tag>photos</tag>
        <tag>航拍</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏人工智能的移动</title>
    <url>/2021/10/10/tech/AIMovement/</url>
    <content><![CDATA[<h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p>游戏中的人工智能指拥有决策能力的智能体，会对环境的改变作出相应的决策。其中，移动是智能体最基本也是最通用的行为。</p>
<p>智能体的移动可以分为三个环节：</p>
<ul>
<li><strong>行为选择</strong>：该部分负责选定目标、制定计划。它来告诉我们“到这来”和“做好A、B，然后做C”。</li>
<li><strong>操控</strong>：该环节负责计算运动数据，根据选择的行为计算得到一个操控力，它决定智能体往哪儿移动以及如何快速移动。</li>
<li><strong>移动</strong>：主要表现智能体运动的机械因素，即控制智能体的移动方式。比如，人和汽车有不同的移动方式，虽然他们具有同样的意向，收到相同的操控力，但是最终的移动表现是完全不同的。</li>
</ul>
<span id="more"></span>
<h3 id="二、模型建立：MovingEntity"><a href="#二、模型建立：MovingEntity" class="headerlink" title="二、模型建立：MovingEntity"></a>二、模型建立：MovingEntity</h3><p>在开始之前首先建立一个最基本的移动智能体的模型，即确定下移动的环节。</p>
<p>通常一个移动的智能体具有以下属性：</p>
<ul>
<li>位置：position</li>
<li>方向：rotation</li>
<li>质量：mass</li>
<li>速度：velocity</li>
<li>操控力：force</li>
<li>最大速度：maxSpeed</li>
<li>最大操控力：maxForce</li>
<li>最大转动速率：maxTurnRate</li>
</ul>
<p>MovingEntity类中需要有Update()方法来每帧更新智能体的物理状态，代码如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (mass == <span class="number">0</span>) mass = <span class="number">1</span>;</span><br><span class="line">		Velocity = Force / mass * Time.deltaTime + Velocity;</span><br><span class="line">		<span class="keyword">if</span> (Velocity.sqrMagnitude &gt; maxSpeed * maxSpeed)</span><br><span class="line">      	Velocity = Velocity.normalized * maxSpeed;</span><br><span class="line">		transform.position += Velocity * Time.deltaTime;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> fn = Velocity.normalized;</span><br><span class="line">		<span class="keyword">var</span> vn = transform.forward;</span><br><span class="line">		<span class="keyword">if</span> (fn == <span class="literal">default</span>) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">var</span> angle = Vector3.Angle(fn, vn);</span><br><span class="line">		<span class="keyword">if</span> (angle &lt; <span class="number">5</span>) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">var</span> axis = Vector3.Cross(fn, vn);</span><br><span class="line">		transform.Rotate(axis, -maxTurnRate * Time.deltaTime, Space.World);</span><br><span class="line">		transform.Rotate(transform.forward * rotationSpeed * Time.deltaTime, Space.World);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三、个体行为"><a href="#三、个体行为" class="headerlink" title="三、个体行为"></a>三、个体行为</h3><p>接下来是最关键的部分，根据不同的行为计算需要施加的操控力。在分析各种行为过程中，我们总是遵循一个公式：</p>
<ul>
<li><strong>操控力 = 预期速度 - 当前速度</strong></li>
</ul>
<h4 id="Seek（靠近）"><a href="#Seek（靠近）" class="headerlink" title="Seek（靠近）"></a>Seek（靠近）</h4><ul>
<li>预期速度：这个速度为智能体在理想状态下到达目标位置所需的速度，方向为智能体到目标位置的向量，大小为最大速度。</li>
<li>所需操控力：方向为 (预期速度-当前速度)，大小为最大操控力大小。</li>
</ul>
<p><img data-src="/image/13-1.png" alt=" " style="zoom:50%;"/></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">Seek</span>(<span class="params"><span class="keyword">this</span> MovingEntity entity, Vector3 target</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">var</span> dis = target - entity.transform.position;</span><br><span class="line">		<span class="keyword">var</span> needVelocity = dis.normalized * entity.maxSpeed;</span><br><span class="line">		<span class="keyword">var</span> deltaVelocity = needVelocity - entity.Velocity;</span><br><span class="line">		<span class="keyword">return</span> deltaVelocity.normalized * entity.maxForce;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="/image/13-20.gif" alt=" " style="zoom:50%;"/></p>
<h4 id="Flee（远离）"><a href="#Flee（远离）" class="headerlink" title="Flee（远离）"></a>Flee（远离）</h4><ul>
<li>预期速度与Seek正好相反。</li>
<li>可以进行适当调整，如当目标进入到一定范围内才产生远离的操控力。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">Flee</span>(<span class="params"><span class="keyword">this</span> MovingEntity entity, Vector3 target, <span class="built_in">float</span> keepDistance</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pos = entity.transform.position;</span><br><span class="line">    <span class="keyword">if</span> ((pos - target).sqrMagnitude &gt;= keepDistance * keepDistance)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (entity.Velocity.sqrMagnitude &lt; <span class="number">0.1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            entity.Stop();</span><br><span class="line">            <span class="keyword">return</span> Vector3.zero;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> entity.Velocity.normalized * <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> needVelocity = (pos - target).normalized * entity.maxSpeed;</span><br><span class="line">    <span class="keyword">var</span> deltaVelocity = needVelocity - entity.Velocity;</span><br><span class="line">    <span class="keyword">return</span> deltaVelocity.normalized * entity.maxForce;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Arrive（抵达）"><a href="#Arrive（抵达）" class="headerlink" title="Arrive（抵达）"></a>Arrive（抵达）</h4><ul>
<li>与Seek不同，Arrive可以实现减速并停在目标位置。当与目标距离大于阈值时算法与Seek相同，当距离小于阈值时需要进行减速。</li>
<li>进入阈值时的预期速度：方向为智能体到目标位置的向量，大小与距离的1/2次幂成正比。</li>
<li>所需操控力：方向为 (预期速度-当前速度)，大小为最大操控力大小。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">Arrive</span>(<span class="params"><span class="keyword">this</span> MovingEntity entity, Vector3 target, <span class="built_in">float</span> slowDownDis = <span class="number">10</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> toTarget = target - entity.transform.position;</span><br><span class="line">    <span class="keyword">var</span> dis = toTarget.magnitude;</span><br><span class="line">    <span class="keyword">if</span> (dis &gt; slowDownDis) <span class="keyword">return</span> entity.Seek(target);</span><br><span class="line">    <span class="keyword">if</span> (dis &gt; <span class="number">0.1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> needSpeed = (<span class="built_in">float</span>)Math.Sqrt(<span class="number">2</span> * entity.maxForce / entity.mass * dis);</span><br><span class="line">        <span class="keyword">var</span> needVelocity = toTarget.normalized * needSpeed;</span><br><span class="line">        <span class="keyword">return</span> (needVelocity - entity.Velocity).normalized * entity.maxForce;</span><br><span class="line">    &#125;</span><br><span class="line">    entity.Stop();</span><br><span class="line">    <span class="keyword">return</span> Vector3.zero;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="/image/13-19.gif" alt=" " style="zoom:50%;"/></p>
<h4 id="Pursuit（追逐）"><a href="#Pursuit（追逐）" class="headerlink" title="Pursuit（追逐）"></a>Pursuit（追逐）</h4><ul>
<li>在追逐目标时，我们通常不会直接向目标的当前位置跑，而是会预测目标未来的位置，向预测的位置跑，期间不断通过调整来缩短差距。</li>
<li>预测目标位置的算法可以变得很复杂，但我们可以做个折衷的选择，在保证足够的精度的同时又不会消耗过多的性能。</li>
<li>我们主要要计算的就是追上的位置距离当前目标的位置有多远，这个距离与当前自己与目标的距离成正比，与目标速度的二次幂成正比，与自己速度的二次幂成反比。</li>
<li>此外，需要考虑一种特殊情况，当目标朝向自己跑时，这时候不需要预测位置，直接朝向目标当前位置跑就能追上了。</li>
</ul>
<p><img data-src="/image/13-2.png" alt=" " style="zoom:50%;"/></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">Pursuit</span>(<span class="params"><span class="keyword">this</span> MovingEntity entity, MovingEntity target, <span class="built_in">float</span> keepDistance = <span class="number">0.1f</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dir = entity.transform.position - target.transform.position;</span><br><span class="line">    <span class="comment">// 追到目标后停止</span></span><br><span class="line">    <span class="keyword">if</span> (dir.sqrMagnitude &lt;= keepDistance * keepDistance)</span><br><span class="line">    &#123;</span><br><span class="line">        entity.Stop();</span><br><span class="line">        <span class="keyword">return</span> Vector3.zero;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当目标朝向自己时，直接向目标当前位置移动</span></span><br><span class="line">    <span class="keyword">if</span> (Vector3.Angle(dir, target.transform.forward) &lt; <span class="number">20</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Seek(entity, target.transform.position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当目标在向其他方向移动时，需要预判目标一段时间后的位置。</span></span><br><span class="line">    <span class="keyword">var</span> tarSpeed = target.Velocity.magnitude;</span><br><span class="line">    <span class="keyword">var</span> lookAheadDis = dir.magnitude * tarSpeed / entity.maxSpeed;</span><br><span class="line">    <span class="keyword">var</span> tarPos = target.transform.position + target.Velocity.normalized * lookAheadDis;</span><br><span class="line">    <span class="keyword">return</span> entity.Seek(tarPos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="/image/13-18.gif" alt=" " style="zoom:50%;"/></p>
<h4 id="Evade-逃避"><a href="#Evade-逃避" class="headerlink" title="Evade(逃避)"></a>Evade(逃避)</h4><ul>
<li>和追逐类似，只是方向相反，且不用检查是否正面。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">Evade</span>(<span class="params"><span class="keyword">this</span> MovingEntity entity, MovingEntity target, <span class="built_in">float</span> keepDistance</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dir = entity.transform.position - target.transform.position;</span><br><span class="line">    <span class="keyword">var</span> tarSpeed = target.Velocity.magnitude;</span><br><span class="line">    <span class="keyword">var</span> lookAheadDis = dir.magnitude * tarSpeed / entity.maxSpeed;</span><br><span class="line">    <span class="keyword">var</span> tarPos = target.transform.position + target.Velocity.normalized * lookAheadDis;</span><br><span class="line">    <span class="keyword">return</span> entity.Flee(tarPos, keepDistance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Wander（徘徊）"><a href="#Wander（徘徊）" class="headerlink" title="Wander（徘徊）"></a>Wander（徘徊）</h4><ul>
<li><strong>定义：</strong>产生一个操控力，使智能体在场景内随机移动。</li>
<li><strong>两个错误（欠优）的思路：</strong>1.使用普通的随机算法每帧都计算一个随机的驱动力：因为随机算法取到的随机数不是连续的，所以无法实现持续的驱动力变化，会产生抖动。2.使用Perlin噪声，可以产生连续的转弯，但是性能开销较大。</li>
<li><strong>Reynolds的解决方案：</strong>在智能体前端突出一个圆圈，目标被限制在该圆圈上。每帧给目标添加一个随机的位移，来产生一个随机但连续的操控力。通过控制圆圈的半径、圆圈到智能体的距离以及每帧随机位移的大小，就能产生各种形式的随机运动。</li>
<li>三维空间中，智能体的目标就改成限制在一个球体上。</li>
</ul>
<p><img data-src="/image/13-4.png" alt=" " style="zoom:50%;"/></p>
<p><img data-src="/image/13-5.png" alt=" " style="zoom:90%;"/></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">Wander</span>(<span class="params"><span class="keyword">this</span> MovingEntity entity, <span class="built_in">float</span> wanderRadius, <span class="built_in">float</span> wanderDistance, <span class="built_in">float</span> wanderJitter,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">bool</span> limit = <span class="literal">true</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    entity.WanderTarget += <span class="keyword">new</span> Vector3(Random.Range(<span class="number">-1</span> * wanderJitter, wanderJitter),</span><br><span class="line">        Random.Range(<span class="number">-1</span> * wanderJitter, wanderJitter), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">var</span> limitParam = limit ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> wanderCirclePoint = entity.Velocity.normalized * wanderDistance + entity.transform.position * limitParam;</span><br><span class="line">    entity.WanderTarget = wanderCirclePoint + wanderRadius * (entity.WanderTarget - wanderCirclePoint).normalized;</span><br><span class="line">    <span class="keyword">return</span> entity.Seek(entity.WanderTarget);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="/image/13-15.gif" alt=" " style="zoom:67%;"/></p>
<p><img data-src="/image/13-16.gif" alt=" " style="zoom:67%;"/></p>
<h4 id="Interpose（插入）"><a href="#Interpose（插入）" class="headerlink" title="Interpose（插入）"></a>Interpose（插入）</h4><ul>
<li><strong>定义：</strong>产生一个操控力，控制智能体移动到两个智能体的中点，可以用于运动员截球，保镖保护老板等行为。</li>
<li><strong>实现方法：</strong><ul>
<li>计算智能体移动到当前两个目标连线中点需要的时间t。</li>
<li>计算t时间后两个目标所在的位置。</li>
<li>连线中点就是智能体的目标位置，使用Arrive移向它。</li>
</ul>
</li>
</ul>
<p><img data-src="/image/13-3.png" alt=" " style="zoom:50%;"/></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">Interpose</span>(<span class="params"><span class="keyword">this</span> MovingEntity entity, MovingEntity targetA, MovingEntity targetB</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> targetAPos = targetA.transform.position;</span><br><span class="line">    <span class="keyword">var</span> targetBPos = targetB.transform.position;</span><br><span class="line">    <span class="keyword">var</span> centerNow = (targetAPos + targetBPos) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">var</span> time = (entity.transform.position - centerNow).magnitude / entity.maxSpeed;</span><br><span class="line">    <span class="keyword">var</span> targetAPosPre = targetAPos + targetA.Velocity * time;</span><br><span class="line">    <span class="keyword">var</span> targetBPosPre = targetBPos + targetB.Velocity * time;</span><br><span class="line">    <span class="keyword">return</span> entity.Arrive((targetAPosPre + targetBPosPre) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="/image/13-17.gif" alt=" " style="zoom:67%;"/></p>
<h4 id="Offset-Pursuit（保持一定偏移的追逐）"><a href="#Offset-Pursuit（保持一定偏移的追逐）" class="headerlink" title="Offset Pursuit（保持一定偏移的追逐）"></a>Offset Pursuit（保持一定偏移的追逐）</h4><ul>
<li><strong>定义：</strong>在追逐的同时保持智能体与目标之间有一个指定的偏移。可用于体育比赛中的盯防、实现战斗编队、空中飞船对接等。</li>
<li><strong>实现思路：</strong>与追逐类似，需要预测下一个带偏移的目标位置，然后用Arrive接近该位置（不能用Seek）。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">OffsetPursuit</span>(<span class="params"><span class="keyword">this</span> MovingEntity entity, MovingEntity target, Vector3 offset</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dir = entity.transform.position - target.transform.position;</span><br><span class="line">    <span class="keyword">var</span> tarSpeed = target.Velocity.magnitude;</span><br><span class="line">    <span class="keyword">var</span> lookAheadDis = dir.magnitude * tarSpeed / entity.maxSpeed;</span><br><span class="line">    <span class="keyword">var</span> tarPos = target.transform.position + target.Velocity.normalized * lookAheadDis +</span><br><span class="line">                 target.transform.TransformVector(offset);</span><br><span class="line">    <span class="keyword">return</span> entity.Arrive(tarPos, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="/image/13-14.gif" alt=" " style="zoom:57%;"/></p>
<h3 id="四、群体行为"><a href="#四、群体行为" class="headerlink" title="四、群体行为"></a>四、群体行为</h3><ul>
<li>在群组中，通常个体的感知范围是有限的，因此每个智能体都有邻域的概念，只有在距离自己一定范围内的智能体才能感知到。这个数据可以以列表的形式存在MovingEntity中，在每一帧去更新这个列表。 </li>
<li>更进一步地，可以增加可视域的限制，智能体只能看见一定视角范围内的其他智能体，来达到更真实的模拟。 </li>
</ul>
<p><img data-src="/image/13-6.png" alt=" " style="zoom:50%;"/></p>
<h4 id="Separation（分离）"><a href="#Separation（分离）" class="headerlink" title="Separation（分离）"></a>Separation（分离）</h4><ul>
<li><strong>定义：</strong>产生一个操控力，使得智能体远离临近的智能体，且这个力的大小反比于两个智能体之间的距离。</li>
<li><strong>结合：</strong>分离可与其他个体行为结合，形成各种群体行为，如群体追逐、群体靠近、群体远离等。</li>
</ul>
<p><img data-src="/image/13-7.png" alt=" " style="zoom:50%;"/></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">Separate</span>(<span class="params"><span class="keyword">this</span> MovingEntity entity, List&lt;MovingEntity&gt; teammate, <span class="built_in">float</span> desiredSeparation = <span class="number">2</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> force = Vector3.zero;</span><br><span class="line">    Vector3 dir;</span><br><span class="line">    <span class="built_in">float</span> dis;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> mv <span class="keyword">in</span> teammate)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mv == entity) <span class="keyword">continue</span>;</span><br><span class="line">        dir = entity.transform.position - mv.transform.position;</span><br><span class="line">        dis = dir.magnitude &gt; <span class="number">0.1f</span> ? dir.magnitude : <span class="number">0.1f</span>;</span><br><span class="line">        <span class="keyword">if</span> (dis &lt;= desiredSeparation)</span><br><span class="line">        &#123;</span><br><span class="line">            force += dir.normalized / dis;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> Vector3.zero;</span><br><span class="line">    <span class="keyword">return</span> force.normalized * entity.maxForce;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Alignment（队列）"><a href="#Alignment（队列）" class="headerlink" title="Alignment（队列）"></a>Alignment（队列）</h4><ul>
<li><strong>定义：</strong>智能体企图与邻域中的智能体保持一致的方向。</li>
<li><strong>预期速度：</strong>邻域中所有智能体的平均速度。 </li>
<li>可用于模拟马路上汽车的运动</li>
</ul>
<p><img data-src="/image/13-8.png" alt=" " style="zoom:50%;"/></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">Align</span>(<span class="params"><span class="keyword">this</span> MovingEntity entity, List&lt;MovingEntity&gt; teammate, <span class="built_in">float</span> neighborDist = <span class="number">10</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> needVelocity = Vector3.zero;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> mv <span class="keyword">in</span> teammate)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mv == entity) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> ((entity.transform.position - mv.transform.position).sqrMagnitude &lt;= neighborDist * neighborDist)</span><br><span class="line">        &#123;</span><br><span class="line">            needVelocity += mv.Velocity;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) <span class="keyword">return</span> Vector3.zero;</span><br><span class="line">    needVelocity /= count;</span><br><span class="line">    <span class="keyword">return</span> (needVelocity - entity.Velocity).normalized * entity.maxForce;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Cohesion（聚集）"><a href="#Cohesion（聚集）" class="headerlink" title="Cohesion（聚集）"></a>Cohesion（聚集）</h4><ul>
<li><strong>定义：</strong>智能体试图朝向邻域中所有智能体的质心移动。</li>
<li><strong>实现思路：</strong>求邻域的质心并靠近（Seek）。 </li>
</ul>
<p><img data-src="/image/13-10.png" alt=" " style="zoom:50%;"/></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">Cohesion</span>(<span class="params"><span class="keyword">this</span> MovingEntity entity, List&lt;MovingEntity&gt; teammate, <span class="built_in">float</span> neighborDist = <span class="number">10</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> center = Vector3.zero;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> mv <span class="keyword">in</span> teammate)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mv == entity) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> ((entity.transform.position - mv.transform.position).sqrMagnitude &lt;= neighborDist * neighborDist)</span><br><span class="line">        &#123;</span><br><span class="line">            center += mv.Velocity;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) <span class="keyword">return</span> Vector3.zero;</span><br><span class="line">    center /= count;</span><br><span class="line">    <span class="keyword">return</span> entity.Seek(center);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Flocking（群集）"><a href="#Flocking（群集）" class="headerlink" title="Flocking（群集）"></a>Flocking（群集）</h4><ul>
<li><strong>鸟群算法（Boids）：</strong>Reynolds提出将分离、队列、聚集三种群体行为以一定权重组合，就能模拟各种群集的移动，如：鸟群、鱼群、羊群等。</li>
<li><strong>特点：</strong>群集不需要任何控制中心或Leader就能实现自发的移动，每个单元都是平等的，受到整体的影响，同时也会影响整体。 </li>
<li>在此基础上可以加入Wander或Seek，保证单位掉队时不会停下。</li>
<li><strong>扩展：</strong>为了达到更自然的模拟效果，可以用Perlin噪声生成权重，使分离、队列、聚集三种行为的权重随着时间变化。</li>
</ul>
<p><img data-src="/image/13-13.gif" alt=" " style="zoom:150%;"/></p>
<h3 id="五、组合操控行为"><a href="#五、组合操控行为" class="headerlink" title="五、组合操控行为"></a>五、组合操控行为</h3><h4 id="带优先级的加权截断总和"><a href="#带优先级的加权截断总和" class="headerlink" title="带优先级的加权截断总和"></a>带优先级的加权截断总和</h4><ul>
<li><p>每个行为都有优先级，按照优先级顺序计算操控力。</p>
</li>
<li><p>每一帧有可用操控力的概念。</p>
</li>
<li><p>计算步骤：</p>
<ul>
<li>计算优先级最高的行为的操控力。</li>
</ul>
<ul>
<li>若该操控力已将可用操控力用完，则不进行后续运算，直接执行该操控力。</li>
<li>若还有剩余的操控力，则进行下一个优先级行为的计算，计算结果按照最大操控力和剩余操控力的值两者的较小值截断。</li>
<li>以此类推直到可用操控力用完。</li>
</ul>
</li>
</ul>
<p><img data-src="/image/13-11.png" alt=" " style="zoom:50%;"/></p>
<h4 id="带优先级的抖动"><a href="#带优先级的抖动" class="headerlink" title="带优先级的抖动"></a>带优先级的抖动</h4><ul>
<li>每个行为都有优先级和执行概率。</li>
<li><p>计算步骤：</p>
<ul>
<li>根据优先级最高行为的执行概率计算是否需要计算该行为的操控力。</li>
<li>如果要求值而且求出的操控力不为零，则直接执行该行为，不考虑其他行为。</li>
<li>否则继续计算下一优先级的行为，以此类推。</li>
</ul>
</li>
<li><p>适用于不需要非常精确的情形。</p>
</li>
</ul>
<p><img data-src="/image/13-12.png" alt=" " style="zoom:50%;"/></p>
<h3 id="六、优化方法"><a href="#六、优化方法" class="headerlink" title="六、优化方法"></a>六、优化方法</h3><ul>
<li>尽量使用距离的平方。</li>
<li>若经常需要计算三角函数，可以建立正余弦查询表。</li>
<li>减少不必要的中间结果变量创建，特别是在循环中。</li>
<li>网格空间分隔<ul>
<li>问题：在群体移动行为相关的算法中，通常每个智能体都需要遍历邻域中的所有智能体，复杂度为O(N2)。</li>
<li>网格空间分隔：将空间分割为若干网格，每个网格维护一个List，储存其中的智能体。每帧开始时根据位置更新所有网格的数据。在具体行为的计算时，每个智能体能根据自己的位置确定处于哪个网格，该网格（或包含相邻网格）下的所有智能体就是自己邻域中的智能体。</li>
<li>复杂度：O(N)</li>
</ul>
</li>
</ul>
<p><strong>参考资料：</strong></p>
<ul>
<li>《游戏人工智能编程案例精粹》第3章：如何创建自治的可移动游戏智能体</li>
<li>《代码本色》第6章：自治智能体</li>
</ul>
<p><strong>Demo地址：</strong><a href="https://github.com/Luciano-0/AIMovement.git">https://github.com/Luciano-0/AIMovement.git</a></p>
]]></content>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
</search>
