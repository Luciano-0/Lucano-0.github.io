<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DoTween</title>
    <url>/2020/09/15/tech/DoTween/</url>
    <content><![CDATA[<h1 id="1-Introdution"><a href="#1-Introdution" class="headerlink" title="1. Introdution"></a>1. Introdution</h1><a id="more"></a>

<h1 id="2-Function"><a href="#2-Function" class="headerlink" title="2. Function"></a>2. Function</h1><h2 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a><strong>Transform</strong></h2><p><code>transform.Func()</code></p>
<h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><ul>
<li><code>DOMove(Vector3 target, float time)</code></li>
<li><code>DOLocalMove()</code></li>
<li><code>DOPunchPosition()</code></li>
</ul>
<h3 id="rotation"><a href="#rotation" class="headerlink" title="rotation"></a>rotation</h3><ul>
<li><code>DORotate()</code></li>
<li><code>DOLocalRotate()</code></li>
<li><code>DORotateQuaternion()</code></li>
<li><code>DOLookat()</code></li>
<li><code>DOPunchRotation()</code></li>
</ul>
<h3 id="scale"><a href="#scale" class="headerlink" title="scale"></a>scale</h3><ul>
<li><code>DOScale()</code></li>
<li><code>DOPunchScale()</code></li>
</ul>
<h3 id="other"><a href="#other" class="headerlink" title="other"></a>other</h3><ul>
<li><code>DOShakePosition()</code>：常用于相机的振动效果</li>
</ul>
<h3 id="blend"><a href="#blend" class="headerlink" title="blend"></a>blend</h3><ul>
<li>如果同时执行两个<code>DOMove()</code>，则前一个会被覆盖，这时需要使用动画混合</li>
<li>实现增量控制</li>
<li><code>DOBlendableMoveBy()</code></li>
<li><code>DOBlendablePunchRotation()</code></li>
</ul>
<h2 id="Material"><a href="#Material" class="headerlink" title="Material"></a><strong>Material</strong></h2><p><code>Material material = GetComponent&lt;MeshRenderer&gt;().material;</code></p>
<p><code>material.Func()</code></p>
<h3 id="color"><a href="#color" class="headerlink" title="color"></a>color</h3><ul>
<li><code>DOColor()</code>：传颜色属性名字</li>
<li><code>DOGradientColor()</code>：渐变颜色动画</li>
</ul>
<h3 id="alpha"><a href="#alpha" class="headerlink" title="alpha"></a>alpha</h3><ul>
<li><p><code>DOColor(Color.clear, time)</code>：通过改变颜色的透明度改变物体透明度</p>
</li>
<li><p><code>DOFade()</code></p>
</li>
</ul>
<h3 id="other-1"><a href="#other-1" class="headerlink" title="other"></a>other</h3><ul>
<li><code>DOOffset()</code>：动态改变uv坐标，可用于特效，如武器流光</li>
<li><code>DOVector()</code>：改变任意material四维向量值</li>
<li><code>DOBlendableColor()</code>：颜色混合</li>
</ul>
<h1 id="3-Tips"><a href="#3-Tips" class="headerlink" title="3. Tips"></a>3. Tips</h1><ul>
<li>函数命名与功能相关，每一类命名都有关键词</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>效率工具备忘录</title>
    <url>/2021/03/11/tech/EfficiencyTool/</url>
    <content><![CDATA[<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><ul>
<li><a href="http://www.1218.io/">Seer</a> 实现类似Mac OS下空格预览文件的功能。</li>
<li><a href="https://www.islide.cc/">iSlide</a> 基于PPT的插件工具，包含查找模板、图片、图标素材、设计配色、页面布局、智能优化等功能。</li>
<li><a href="https://everything.en.softonic.com/">Everything</a> 全局文件搜索</li>
<li><a href="http://www.wox.one/">Wox</a> 实现类似Mac OS下Spot Light的功能，搭配Everything食用更佳。</li>
<li><a href="https://github.com/microsoft/PowerToys/releases">PowerToys</a> 微软开发的开源效率工具，支持快速修改图片分辨率、批量文件重命名、Wox的大部分功能(暂时不支持与Everything配合使用)。<a href="https://docs.microsoft.com/zh-cn/windows/powertoys/">Microsoft PowerToys | Microsoft Docs</a></li>
<li><a href="https://www.typora.io/">Typora</a> 用过颜值最高的Markdown编辑器。</li>
</ul>
<a id="more"></a>

<h3 id="Mac-OS"><a href="#Mac-OS" class="headerlink" title="Mac OS"></a>Mac OS</h3><ul>
<li><strong>Bob</strong> 全局翻译软件</li>
<li><strong>MonitorControl</strong> 控制显示器亮度</li>
<li><strong>超级右键</strong> 右键菜单工具</li>
<li><strong>Xnip</strong> 截图工具，支持滚动截图</li>
<li><strong>Unsplash Wallpapers</strong> 壁纸</li>
<li><strong>Cheat Sheet</strong> 快捷键查看工具</li>
<li><strong>Keka</strong> 解压工具</li>
<li><strong>Tencent Lemon</strong> 管家</li>
<li><strong>Mos</strong> 鼠标优化</li>
<li><strong>Rectangle</strong> 窗口调整工具</li>
</ul>
<h3 id="Edge-Chrome插件"><a href="#Edge-Chrome插件" class="headerlink" title="Edge/Chrome插件"></a>Edge/Chrome插件</h3><ul>
<li><a href="https://microsoftedge.microsoft.com/addons/detail/adblock-%E2%80%94-%E6%9C%80%E4%BD%B3%E5%B9%BF%E5%91%8A%E6%8B%A6%E6%88%AA%E5%B7%A5%E5%85%B7/ndcileolkflehcjpmjnfbnaibdcgglog">AdBlock</a></li>
<li><a href="https://microsoftedge.microsoft.com/addons/detail/infinity-%E6%96%B0%E6%A0%87%E7%AD%BE%E9%A1%B5-pro/hajlmbnnniemimmaehcefkamdadpjlfa">Infinity 新标签页 (Pro)</a></li>
<li><a href="https://microsoftedge.microsoft.com/addons/detail/tampermonkey/iikmkjmpaadaobahmlepeloendndfphd">Tampermonkey</a></li>
<li><a href="">Imagus</a> 图片预览</li>
</ul>
<h3 id="JetBrains插件"><a href="#JetBrains插件" class="headerlink" title="JetBrains插件"></a>JetBrains插件</h3><ul>
<li><strong>Translation</strong> 翻译工具</li>
<li><strong>Nyan Progress Bar</strong> 彩虹猫进度条</li>
<li><strong>GitToolBox</strong> Git工具</li>
<li><strong>Chinese(Simplified) Language Pack EAP</strong> 汉化包</li>
<li><strong>CodeGlance</strong> 代码预览滚动条</li>
<li><strong>Background Image Plus</strong> 设置IDE背景</li>
<li><strong>Leetcode editor</strong> IDE刷Leetcode神器</li>
<li><strong>AIXcoder Code Completer</strong> 代码补全工具</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Lua小技巧及语法糖记录</title>
    <url>/2020/10/27/tech/Lua-1/</url>
    <content><![CDATA[<p>在Lua的学习过程中，发现有许多特别或是巧妙的语法，特在此记录。</p>
<p>参考书籍：<a href="https://book.douban.com/subject/30262035/">《Lua程序设计（第4版）》</a></p>
<a id="more"></a>

<h4 id="注释代码"><a href="#注释代码" class="headerlink" title="注释代码"></a>注释代码</h4><p>Lua中使用<code>--</code>表示单行注释，<code>--[[ 多行长注释 ]]</code>表示多行长注释，在注释代码时，常见的技巧是将代码放入<code>--[[</code> 和 <code>--]]</code>之间，如：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">print(10)</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure>

<p>当需要重新启用这段代码时只需要在第一行行首添加一个连字符。</p>
<h4 id="逻辑运算and、or"><a href="#逻辑运算and、or" class="headerlink" title="逻辑运算and、or"></a>逻辑运算and、or</h4><ul>
<li><p>and：如果第一个操作数为”false”，则返回第一个操作数，否则返回第二个操作数。</p>
</li>
<li><p>or：如果第一个操作数不为”false”，则返回第一个操作数，否则返回第二个操作数。</p>
</li>
<li><p>and和or都遵循短路求值。</p>
</li>
<li><p>形如<code>x=x or v</code>的写法非常有用，等价于<code>if not x the x=v end</code></p>
</li>
<li><p>形如<code>(a and b or c)</code>，当b不为false时，等价于C语言中的三目运算符<code>a ? b : c</code></p>
</li>
</ul>
<h4 id="取模运算"><a href="#取模运算" class="headerlink" title="取模运算"></a>取模运算</h4><p><code>x-x%0.01</code>表示x保留两位小数的结果。</p>
<h4 id="全局变量本质为表"><a href="#全局变量本质为表" class="headerlink" title="全局变量本质为表"></a>全局变量本质为表</h4><p>Lua语言使用表来储存全局变量，未经初始化的表元素为nil，将nil赋值给表元素可以将它删除，这样的操作对全局变量同样适用。</p>
<h4 id="a-name和a-name-和a-quot-name-quot"><a href="#a-name和a-name-和a-quot-name-quot" class="headerlink" title="a.name和a[name]和a[&quot;name&quot;]"></a><code>a.name</code>和<code>a[name]</code>和<code>a[&quot;name&quot;]</code></h4><ul>
<li><p>当把表当作结构体用时，可以把索引当作成员名称使用，因此<code>a.name</code>等价于<code>a[&quot;name&quot;]</code>，在Lua中，这两种形式自由混用。</p>
</li>
<li><p>但对于阅读程序的人而言，两种形式代表了不同的意图，点分式说明当前表被当作结构体使用，此时表实际上是由固定的、预先定义的键组成的集合；而字符串索引形式说明表可以使用任意字符作为键，并且处于某种原因我们操作的是指定键。</p>
</li>
<li><p>而<code>a.x</code>和<code>a[x]</code>是不等价的，不能搞混。</p>
</li>
</ul>
<h4 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h4><ul>
<li>所有元素不为nil的数组称之为序列，Lua提供了获取序列长度的操作符#</li>
<li>对于中间存在空洞的列表而言，序列长度操作符是不可靠的。</li>
<li>准确地说，序列是由指定的n个正整数值类型的键所组成的集合{1,2,…,n}形成的表。</li>
</ul>
<h4 id="遍历表"><a href="#遍历表" class="headerlink" title="遍历表"></a>遍历表</h4><ul>
<li><code>pairs()</code>：遍历顺序随机，相同程序在不同时间运行也可能产生不同的结果，但每个元素会出现一次。</li>
<li><code>ipairs()</code>：按顺序遍历。</li>
<li>使用数值型for循环。</li>
</ul>
<h4 id="函数语法糖"><a href="#函数语法糖" class="headerlink" title="函数语法糖"></a>函数语法糖</h4><ul>
<li><p>当函数只有一个参数且该参数是字符串常量或是表构造器时，括号可省略。</p>
</li>
<li><p>Lua语言为面向对象风格的调用提供了一种特殊的语法，<code>o:foo(x)</code>，即调用对象o的foo方法。</p>
</li>
<li><p>调用函数时使用的参数个数可以与定义函数时使用的参数个数不一致，Lua语言会通过抛弃多余的参数和将参数设为nil来调整参数的个数。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏中的运动补偿</title>
    <url>/2020/11/22/tech/MotionCompensation/</url>
    <content><![CDATA[<h2 id="玩家角色的客户端预测与服务器对账"><a href="#玩家角色的客户端预测与服务器对账" class="headerlink" title="玩家角色的客户端预测与服务器对账"></a>玩家角色的客户端预测与服务器对账</h2><h3 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h3><ul>
<li><p>在多人游戏中，外挂作弊不只是让自己的游戏体验更好，还会让其他玩家的游戏体验更差，因此在开发过程中需要避免这种情况的发生。</p>
</li>
<li><p><strong>权威服务器和哑客户端</strong>：为处理外挂问题，游戏中的逻辑通常只由服务器处理，客户端只负责显示，一切以服务器为准。</p>
</li>
<li><p>此方案在慢节奏的游戏中运行良好，但遇到快速刷新的游戏就要考虑网络延迟的问题。比如考虑一个实际场景，客户端发出指令向前运动一米，指令需要传给服务器（花费100 ms），服务器处理后返回角色运动一米后所在的位置（花费100 ms），再由客户端在画面上表现出来。因此在玩家发出指令后将在200 ms内游戏画面没有任何变化然后突然向前运动了一米。这种滞后对游戏来说当然是灾难性的。</p>
<a id="more"></a>

</li>
</ul>
<h3 id="客户端预测"><a href="#客户端预测" class="headerlink" title="客户端预测"></a>客户端预测</h3><ul>
<li>通常游戏世界是具有足够确定性的，即给定一个游戏状态和一组输入，结果是完全可预测的。因此基于此确定性，我们可以在客户端发出指令之后在等待服务器回应期间就开始呈现效果，这样既保证了服务器的权威性，又能消除表现上的割裂感。</li>
<li>以上方案看似已经完美解决了问题，但考虑一下当玩家的连续操作时间间隔小于网络延迟的时候就会出现问题。比如：玩家连续按下两次向前移动一米的操作，移动所需时间为100 ms，但网络延迟有250 ms，这就会导致在200 ms时角色在前进两米的位置，但250 ms时收到服务器的第一次消息强制更新回到前进一米的位置，而在350 ms时又会更新到前进两米的位置。这一问题就需要服务器对账来解决。</li>
</ul>
<h3 id="服务器对账"><a href="#服务器对账" class="headerlink" title="服务器对账"></a>服务器对账</h3><ul>
<li>在客户端向服务器发送请求时加入一个序号，当服务器回复时，包括它处理的最后一个序号。借此客户端可以根据服务器发送的最后一个权威的状态以及服务器未处理的输入计算游戏当前的状态。</li>
</ul>
<h2 id="多人游戏其他玩家：实体插值和滞后补偿"><a href="#多人游戏其他玩家：实体插值和滞后补偿" class="headerlink" title="多人游戏其他玩家：实体插值和滞后补偿"></a>多人游戏其他玩家：实体插值和滞后补偿</h2><h3 id="多人游戏带来的新问题"><a href="#多人游戏带来的新问题" class="headerlink" title="多人游戏带来的新问题"></a>多人游戏带来的新问题</h3><ul>
<li><strong>服务器时间步进</strong>：当有多个客户端同时高频次地向服务器发送请求时，每次输入都更新游戏世界会消耗太多的CPU和带宽，因此通常会对客户端的输入进行排队，设置一个服务器步进时间，如100 ms，在该时间段内对所有收到的操作进行统一处理并广播给客户端。</li>
<li><strong>客户端处理低频更新</strong>：对于玩家自己控制的角色来说处理和前文所述基本一致，能靠预测填充服务器两次消息间信息的空白，但是对于其他玩家控制的角色来说，获得的信息就会比较稀疏，如何在数据有限的情况下对其他玩家控制角色的运动进行平滑就是新的问题。</li>
</ul>
<h3 id="Dead-reckoning-死亡计算"><a href="#Dead-reckoning-死亡计算" class="headerlink" title="Dead reckoning 死亡计算"></a>Dead reckoning 死亡计算</h3><ul>
<li><p>在某些游戏如赛车游戏中，客户端可以获取权威的速度、加速度等运动参数，在下一次服务器数据到来之前，假设在此期间汽车不发生运动参数的突变（如发生碰撞、用户输入等），客户端根据当前参数预测汽车的运动，在服务器数据到来之后进行更正。</p>
</li>
<li><p><strong>限制：</strong>在某些情况下，死亡计算完全无法使用，例如在射击游戏中，玩家的方向和速度是可以立刻改变的，此时，玩家以较高的频率和飞快的速度进行转向、加速、停止，因此，完全无法根据当前的运动参数预测接下来的运动。</p>
</li>
</ul>
<h3 id="实体插值"><a href="#实体插值" class="headerlink" title="实体插值"></a>实体插值</h3><ul>
<li>另一种解决方法是实体插值，例如，在t=1000 ms时，客户端已经收到了来自服务器t=900 ms和t=1000 ms的可靠数据，在1000 ms到1100 ms期间，客户端就显示对900 ms和1000 ms插值之后的数据。在此种解决方案下，插值获得的显示效果是流畅且足够准确的，唯一的问题是客户端显示的是100 ms前的数据。 </li>
</ul>
<h3 id="滞后补偿"><a href="#滞后补偿" class="headerlink" title="滞后补偿"></a>滞后补偿</h3><ul>
<li><strong>最后需要解决一个问题：</strong>实体插值带来的延迟。当下，玩家看到的实际是自己当前的位置状态和100 ms前其他玩家的位置状态。在某些情况下，这100 ms的延迟也是致命的，如：你向着敌人开枪，但你瞄准的实际上是100 ms前的敌人，此时敌人的位置已经不在你看到的位置。</li>
<li><strong>解决方案：</strong>当玩家按下射击按钮时，客户端会向服务器发送当前事件，包含准确的时间戳和目标。服务器接收到数据后会根据时间戳重建过去的世界，处理射击的结果并发送给客户端。唯一的问题是敌人有可能在掩体后被杀，因为他实际上是在100 ms前运动到掩体前被杀的，但做了延迟处决。</li>
</ul>
<p>参考：</p>
<p><a href="https://www.gabrielgambetta.com/client-server-game-architecture.html">Client Server Game Architecture</a></p>
<p><a href="https://developer.valvesoftware.com/wiki/Latency_Compensating_Methods_in_Client/Server_In-game_Protocol_Design_and_Optimization#Game_Design_Implications_of_Lag_Compensation">Latency Compensating Methods in Client/Server In-game Protocol Design and Optimization</a></p>
]]></content>
      <tags>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title>一种Lua反射调用C#机制的实现</title>
    <url>/2021/04/09/tech/NativeChannel/</url>
    <content><![CDATA[<h4 id="一-概述"><a href="#一-概述" class="headerlink" title="一   概述"></a>一   概述</h4><p>NativeChannel提供Lua层通过反射调用C#层代码的机制，支持对静态类和非静态类中属性、方法、委托的调用，并支持在Lua层使用宏定义对代码进行隔离。通过NativeChannel可以不生成额外的wrap文件来达到Lua层访问C#层的效果，调用更加灵活，适合需要集成到Lua层但又要灵活增删的模块（如SDK）。</p>
<a id="more"></a>

<h4 id="二-实现"><a href="#二-实现" class="headerlink" title="二   实现"></a>二   实现</h4><p>实现的大致思路为封装两个类<code>AnyObject</code>和<code>AnyStaticObject</code>暴露到Lua层，这两个类都实现<code>IAny</code>接口。这两个类包含对具体类中的生命周期、属性、方法、委托的所有操作。再定义通道类<code>NativeChannel</code>，实现INativeChannel和<code>IServiceStart</code>接口，包装成Service管理所有反射调用的类。</p>
<h5 id="1-Object"><a href="#1-Object" class="headerlink" title="1.Object"></a>1.<code>Object</code></h5><ul>
<li>Interface</li>
</ul>
<p><code>AnyObject</code>和<code>AnyStaticObject</code>都实现了<code>IAny</code>接口，它们之间的区别是前者储存了目标类实例的引用<code>target</code>，在使用时调用属性、方法需要传入该引用；而后者储存的是静态类的类型。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IAny</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">OnStart</span>(<span class="params"></span>)</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">OnUpdate</span>(<span class="params"><span class="keyword">float</span> deltaTime</span>)</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">OnEnd</span>(<span class="params"></span>)</span>;</span><br><span class="line">	<span class="function"><span class="keyword">object</span> <span class="title">Get</span>(<span class="params"><span class="keyword">string</span> prop</span>)</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Set</span>(<span class="params"><span class="keyword">string</span> prop, <span class="keyword">object</span> <span class="keyword">value</span></span>)</span>;</span><br><span class="line">	<span class="function"><span class="keyword">object</span> <span class="title">Call</span>(<span class="params"><span class="keyword">string</span> method, <span class="keyword">params</span> <span class="keyword">object</span>[] args</span>)</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">AddDelegate</span>(<span class="params"><span class="keyword">string</span> del, <span class="keyword">string</span> func, LuaTable self = <span class="literal">null</span></span>)</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">AddDelegate</span>(<span class="params"><span class="keyword">string</span> del, LuaFunction func</span>)</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">RemoveDelegate</span>(<span class="params"><span class="keyword">string</span> del, <span class="keyword">string</span> func, LuaTable self = <span class="literal">null</span></span>)</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">RemoveDelegate</span>(<span class="params"><span class="keyword">string</span> del, LuaFunction func</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Life cycle</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnStart</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> method = <span class="keyword">this</span>.target.GetType().GetMethod(<span class="string">&quot;OnStart&quot;</span>);</span><br><span class="line">	method?.Invoke(<span class="keyword">this</span>.target, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>(<span class="params"><span class="keyword">float</span> deltaTime</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> method = <span class="keyword">this</span>.target.GetType().GetMethod(<span class="string">&quot;OnRefresh&quot;</span>);</span><br><span class="line">	Object[] p = <span class="keyword">new</span> Object[] &#123;deltaTime&#125;;</span><br><span class="line">	method?.Invoke(<span class="keyword">this</span>.target, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEnd</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> method = <span class="keyword">this</span>.target.GetType().GetMethod(<span class="string">&quot;OnEnd&quot;</span>);</span><br><span class="line">	method?.Invoke(<span class="keyword">this</span>.target, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>Property</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">object</span> <span class="title">Get</span>(<span class="params"><span class="keyword">string</span> prop</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.target.GetType().GetProperty(prop)?.GetValue(<span class="keyword">this</span>.target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Set</span>(<span class="params"><span class="keyword">string</span> prop, <span class="keyword">object</span> <span class="keyword">value</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> propInfo = <span class="keyword">this</span>.target.GetType().GetProperty(prop);</span><br><span class="line">	<span class="keyword">if</span> (propInfo != <span class="literal">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">value</span> = ConvertType(propInfo.PropertyType, <span class="keyword">value</span>);</span><br><span class="line">		propInfo?.SetValue(<span class="keyword">this</span>.target, <span class="keyword">value</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Method</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">object</span> <span class="title">Call</span>(<span class="params"><span class="keyword">string</span> method, <span class="keyword">params</span> <span class="keyword">object</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> methodInfo = <span class="keyword">this</span>.target.GetType().GetMethod(method);</span><br><span class="line">	<span class="keyword">var</span> parameters = methodInfo?.GetParameters();</span><br><span class="line">	<span class="keyword">if</span> (args.Length != parameters?.Length)</span><br><span class="line">	&#123;</span><br><span class="line">		Debug.LogError(<span class="string">&quot;Wrong parameters!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameters.Length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		args[i] = ConvertType(parameters[i].ParameterType, args[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> methodInfo?.Invoke(<span class="keyword">this</span>.target, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>Delegate</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddDelegate</span>(<span class="params"><span class="keyword">string</span> del, <span class="keyword">string</span> func, LuaTable self = <span class="literal">null</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> eventInfo = <span class="keyword">this</span>.target.GetType().GetEvent(del);</span><br><span class="line">	<span class="keyword">var</span> eventHandlerType = eventInfo.EventHandlerType;</span><br><span class="line">	<span class="keyword">var</span> eventArgs = eventHandlerType.GetMethod(<span class="string">&quot;Invoke&quot;</span>)?.GetParameters();</span><br><span class="line">	Type type;</span><br><span class="line">	<span class="keyword">if</span> (eventArgs == <span class="literal">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		type = <span class="literal">null</span>;</span><br><span class="line">		eventHandlerType = <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> args = <span class="keyword">new</span> Type[eventArgs.Length];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; eventArgs.Length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		args[i] = eventArgs[i].ParameterType;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (eventArgs.Length)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		type = <span class="keyword">typeof</span>(Handler);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		type = <span class="keyword">typeof</span>(Handler&lt;&gt;).MakeGenericType(args);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		type = <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (type == <span class="literal">null</span> || eventHandlerType == <span class="literal">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> helper = Activator.CreateInstance(type, func, self);</span><br><span class="line">	<span class="keyword">var</span> handler = Delegate.CreateDelegate(eventHandlerType, helper, <span class="string">&quot;Handle&quot;</span>);</span><br><span class="line">	eventInfo.AddEventHandler(<span class="keyword">this</span>.target, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-NativeChannel"><a href="#2-NativeChannel" class="headerlink" title="2. NativeChannel"></a>2. <code>NativeChannel</code></h5><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">LuaUsage</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">INativeChannel</span></span><br><span class="line">&#123;</span><br><span class="line">	[<span class="meta">LuaIgnore</span>]</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Register</span>(<span class="params"><span class="keyword">string</span> name, Func&lt;<span class="keyword">object</span>&gt; factory</span>)</span>;</span><br><span class="line">        </span><br><span class="line">	<span class="function">IAny <span class="title">Get</span>(<span class="params"><span class="keyword">string</span> name</span>)</span>;</span><br><span class="line"></span><br><span class="line">	[<span class="meta">LuaIgnore</span>]</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Define</span>(<span class="params"><span class="keyword">string</span> macro</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>NativeChannel</code>中维护一个字典<code>factories</code>存储所有反射调用的类，维护一个列表<code>macros</code>存储所有在Lua层需要添加的宏定义。</p>
<ul>
<li>Register()</li>
</ul>
<p>提供在C#层注册Object的方法</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Register</span>(<span class="params"><span class="keyword">string</span> name, Func&lt;<span class="keyword">object</span>&gt; factory</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.factories.Add(name, () =&gt; <span class="keyword">new</span> AnyObject(factory()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Get()</li>
</ul>
<p>暴露到Lua层，供Lua层通过类名获取对应的引用，若字典中存在该类型则直接返回，若不存在则创建对应的Object。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IAny <span class="title">Get</span>(<span class="params"><span class="keyword">string</span> name</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.factories.TryGetValue(name, <span class="keyword">out</span> <span class="keyword">var</span> factory))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> factory();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> type = Type.GetType(name);</span><br><span class="line">	<span class="keyword">if</span> (type == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (type.IsAbstract &amp;&amp; type.IsSealed)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> AnyStaticObject(type);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">var</span> obj = Activator.CreateInstance(type);</span><br><span class="line">		<span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> AnyObject(obj);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>Define()</li>
</ul>
<p>在C#层中添加宏定义。</p>
<h4 id="三-问题与解决方法"><a href="#三-问题与解决方法" class="headerlink" title="三  问题与解决方法"></a>三  问题与解决方法</h4><h5 id="1-类型转换"><a href="#1-类型转换" class="headerlink" title="1. 类型转换"></a>1. 类型转换</h5><p>对于属性的赋值和方法的参数，Lua层传递过来的数据在C#中为Object类型，需要根据目标类型进行显式的转换。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">object</span> <span class="title">ConvertType</span>(<span class="params">Type type, <span class="keyword">object</span> <span class="keyword">value</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (type == <span class="keyword">typeof</span>(<span class="keyword">short</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> Convert.ToInt16(<span class="keyword">value</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-委托的调用"><a href="#2-委托的调用" class="headerlink" title="2. 委托的调用"></a>2. 委托的调用</h5><ul>
<li><p>为了能正确调用委托，需要确定委托的参数和类型，因此需要特别封装各种参数数量的泛型类<code>Handler</code>，每种<code>Handler</code>类包含构造方法<code>Handler()</code>和触发回调方法的函数<code>Handle()</code>。</p>
</li>
<li><p>在委托添加方法时，先获取方法所有的参数，根据参数个数和每个参数的类型确定<code>Handler</code>的类型：<code>type = typeof(Handler&lt;&gt;).MakeGenericType(args);</code>。</p>
</li>
<li><p>接着使用<code>var helper = Activator.CreateInstance(type, func, self);</code>构造实例。</p>
</li>
<li><p>最后绑定方法</p>
<p><code>var handler = Delegate.CreateDelegate(eventHandlerType, helper, &quot;Handle&quot;); eventInfo.AddEventHandler(this.target, handler);</code></p>
<p>至此，当委托触发时，就能调用到对应<code>Handler</code>类中的<code>Handle()</code>方法，通过该方法再触发Lua层对应的方法，实现动态的绑定调用。</p>
</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Handler</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">readonly</span> <span class="keyword">string</span> funcName;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">readonly</span> LuaTable self;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">readonly</span> LuaFunction func;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Handler</span>(<span class="params"><span class="keyword">string</span> funcName, LuaTable self = <span class="literal">null</span></span>)</span></span><br><span class="line"><span class="function"></span>	&#123;</span><br><span class="line">		<span class="keyword">this</span>.funcName = funcName;</span><br><span class="line">		<span class="keyword">this</span>.self = self;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Handler</span>(<span class="params">LuaFunction func</span>)</span></span><br><span class="line"><span class="function"></span>	&#123;</span><br><span class="line">		<span class="keyword">this</span>.func = func;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span>(<span class="params">T1 a, T2 b</span>)</span></span><br><span class="line"><span class="function"></span>	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.func == <span class="literal">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (self == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">			<span class="keyword">if</span> (!(self[funcName] <span class="keyword">is</span> LuaFunction f)) <span class="keyword">return</span>;</span><br><span class="line">			f.Call(self, a, b);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			func.Call(a, b);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-IL2CPP裁剪代码问题"><a href="#3-IL2CPP裁剪代码问题" class="headerlink" title="3. IL2CPP裁剪代码问题"></a>3. IL2CPP裁剪代码问题</h5><ul>
<li>[**什么是代码裁剪**](<a href="https://docs.unity3d.com/Manual/ManagedCodeStripping.html">Unity - Manual: Managed code stripping (unity3d.com)</a>)  当Unity中的Scripting Backend为IL2CPP时，默认会勾选代码裁剪，此时，构建时Unity代码裁剪工具会分析项目中的程序集，查找和删除未使用的代码，裁剪掉没有使用到的代码。</li>
<li><strong>带来问题</strong>  [参考Unity官方回答](<a href="https://forum.unity.com/threads/il2cpp-type-makegenerictype-work-around.311926/">IL2CPP Type.MakeGenericType work around - Unity Forum</a>) 问题主要出在<code>MakeGenericType()</code>方法上，该方法作用为：替代由当前泛型类型定义的类型参数组成的类型数组的元素，并返回表示结果构造类型的 Type 对象。目前IL2CPP还没有完全支持该方法，只能处理代码中已有的类型。</li>
<li><strong>解决方法</strong>  可以通过在代码中明确声明需要使用到的类型来规避这一问题。额外定义特性用于修饰委托。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Delegate)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NativeHandle</span> : <span class="title">Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">NativeHandle</span>(<span class="params">Type type</span>)</span></span><br><span class="line"><span class="function"></span>	&#123;</span><br><span class="line">		<span class="keyword">this</span>.Type = type;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Type Type &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125; = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">NativeHandle(typeof(Handler&lt;int&gt;))</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">InitCompleteHandler</span>(<span class="params"><span class="keyword">int</span> retCode</span>)</span>;</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>Lua</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>状态模式和职责链模式</title>
    <url>/2022/01/22/tech/StateAndDuty/</url>
    <content><![CDATA[<h3 id="故事背景"><a href="#故事背景" class="headerlink" title="故事背景"></a>故事背景</h3><p>最近在项目中负责任务系统相关的内容，刚重写了整个任务系统，趁热对过程中的心得做一点总结。</p>
<h3 id="原任务系统——状态模式"><a href="#原任务系统——状态模式" class="headerlink" title="原任务系统——状态模式"></a>原任务系统——状态模式</h3><p>原来的任务系统是一个多层状态机，第一层控制不同大类任务之间的切换（如主线任务、分支任务），第二层控制不同种类任务之间的切换（如刷怪任务、剧情任务），第三层控制一个任务下不同行为状态之间的切换（如跑到某地、刷怪、对话等行为）。三层状态机中，中间层使用了状态模式实现，其余两层使用判断进行状态切换。在游戏设计之初，这种设计方法可能可以满足策划的需求，但随着需求的增多，问题就逐渐暴露出来，大致可以总结出几个问题：</p>
<a id="more"></a>

<ul>
<li><strong>代码冗余，可读性差：</strong>在不同种类的任务中可能会存在相同的行为，如刷怪任务和NPC对话任务都有跑到指定地点的行为，为了能让代码复用，这些公共的行为就被提出来写在了Manager中供状态调用，但是在不同任务中，执行完该行为后切换的下一个行为又是不同的，因此在行为的方法中又需要对当前行为进行判断。整体上来看，表示不同种类任务的状态类中只有状态的切换，具体的逻辑都在Manager中，使得Manager类十分庞杂，阅读时需要在状态类和Manager之间来回切换，不是非常直观。</li>
<li><strong>灵活性差、无法应对多变的需求：</strong>这一点是状态模式本身的特点导致的，状态模式在类的设计中就确定了状态之间的转换，其转换关系是确定的，规范的状态模式客户都不知道状态之间的切换的结构，这样的设计非常稳定，但缺点就是灵活性差，耦合度高。但在游戏制作过程中，任务相关的需求总是多变的，比如策划突然想在前往某地和刷怪之间增加一个播放Timeline的环节，那么使用状态模式设计的任务系统就需要添加一个名为播放Timeline的状态，需要在原前往某地的状态切换中将下一个状态从刷怪改为播放Timeline，这就违反了设计原则中的<strong>开闭原则</strong>。</li>
</ul>
<h3 id="新任务系统——职责链模式"><a href="#新任务系统——职责链模式" class="headerlink" title="新任务系统——职责链模式"></a>新任务系统——职责链模式</h3><p>在设计新任务系统时，考虑到一个任务中的步骤可能会经常变化，因此需要使用更加灵活的设计模式来应对变化。新的系统主体采用职责链模式，定义好各种事件，每个事件中处理进入事件、更新事件、退出事件等方法，在执行一个任务前，根据策划的配置从事件库中取出需要执行的事件包装成事件链，这一事件链就构成了这一个任务的整体流程，接着就只需要按照顺序依次触发事件的执行。这样设计的优点在于：</p>
<ul>
<li><strong>减少判断，流程更清晰：</strong>职责链模式在环境类中就组装好事件序列，在具体的事件类中，不需要知道后续的事件做什么，减少if-else判断，只需要维护<code>Execute()</code> <code>Update()</code> <code>OnFinish()</code>等方法，更加纯粹。</li>
<li><strong>灵活性高，使策划能够随意调整任务流程。</strong></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>状态模式适用于状态间的切换关系确定且不是很复杂的情况，也适用于一些需要根据用户输入改变状态的情况，其本质相当于if-else。</li>
<li>职责链模式适合事件执行顺序复杂多变，但执行开始之前事件序列已经确定的情况，其本质相当于switch-case。</li>
</ul>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>初见Processing</title>
    <url>/2020/10/18/tech/Processing-1/</url>
    <content><![CDATA[<h2 id="新大陆"><a href="#新大陆" class="headerlink" title="新大陆"></a>新大陆</h2><p>前几天开始看 Daniel Shiffman的<a href="https://book.douban.com/subject/26264736/">《代码本色：用编程模拟自然系统》</a>，接触到了Processing这种编程语言，就像发现了新大陆。Processing号称为艺术而生的语言，确实，从使用体验到运行效果，都能透露出一份独特的优雅。</p>
<a id="more"></a>

<p>Processing设计的思路就是使用图形化替代原来的命令行，正是这种初衷赋予了这门语言生命，编写几行简单的代码，点击运行按钮就能看到生动的演示效果。</p>
<p>在使用体验上，Processing简单但不简陋，下载后直接打开就能进行编程，不需要复杂的配置环境过程。窗口有点类似单片机的编程，而编程体验类似于Python，且由于开放的社区环境，有许多功能强大的扩展包可以安装。</p>
<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ul>
<li><a href="https://processing.org/">官网</a></li>
<li><a href="http://iprocessing.cn/%E6%96%87%E6%A1%A3/">文档</a></li>
<li>社区：<a href="https://www.openprocessing.org/">OpenProcessing</a> / <a href="http://iprocessing.cn/">Processing编程艺术</a></li>
<li>书籍：<a href="https://book.douban.com/subject/3143256/">Learning Processing</a> / <a href="https://book.douban.com/subject/20452058/">The Nature of Code</a></li>
</ul>
<h2 id="一个小尝试"><a href="#一个小尝试" class="headerlink" title="一个小尝试"></a>一个小尝试</h2><p>迫不及待就仿照书中的例程编写了一个简单的Demo，模拟的是多个小球与中间大球之间的引力作用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Mover[] movers = new Mover[<span class="number">2000</span>];</span><br><span class="line">Attractor a;</span><br><span class="line"></span><br><span class="line">void setup() &#123;</span><br><span class="line">	size(<span class="number">1600</span>, <span class="number">900</span>);</span><br><span class="line">	<span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; movers.length; i++) &#123;</span><br><span class="line">	movers[i] = new Mover();</span><br><span class="line">	&#125;</span><br><span class="line">	a = new Attractor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void draw() &#123;</span><br><span class="line">	background(<span class="number">50</span>);</span><br><span class="line">	<span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; movers.length; i++) &#123;</span><br><span class="line">	PVector force = a.attract(movers[i]);</span><br><span class="line">	movers[i].applyForce(force);</span><br><span class="line">	movers[i].update();</span><br><span class="line">	movers[i].display();</span><br><span class="line">	&#125;</span><br><span class="line">	//a.display();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Mover &#123;</span><br><span class="line">	PVector location;</span><br><span class="line">	PVector velocity;</span><br><span class="line">	PVector acceleration;</span><br><span class="line">	float mass;</span><br><span class="line">	color mycolor;</span><br><span class="line">	</span><br><span class="line">	Mover() &#123;</span><br><span class="line">	location = new PVector(random(width / <span class="number">4</span>, width * <span class="number">3</span> / <span class="number">4</span>), random(height / <span class="number">4</span>, height * <span class="number">3</span> / <span class="number">4</span>));        </span><br><span class="line">	mass = random(<span class="number">0.5</span>, <span class="number">1</span>);</span><br><span class="line">	velocity = new PVector(random(<span class="number">0</span>, <span class="number">1</span>), random(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">	mycolor = color(<span class="number">200</span>, random(<span class="number">0</span>, <span class="number">200</span>), random(<span class="number">0</span>, <span class="number">200</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	void update() &#123;</span><br><span class="line">	velocity.add(acceleration);</span><br><span class="line">	location.add(velocity);</span><br><span class="line">	acceleration.mult(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	void display() &#123;</span><br><span class="line">	stroke(<span class="number">0</span>);</span><br><span class="line">	fill(mycolor);</span><br><span class="line">	ellipse(location.x, location.y, mass * <span class="number">16</span>, mass * <span class="number">16</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	void applyForce(PVector force) &#123;</span><br><span class="line">	acceleration = force;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Attractor &#123;</span><br><span class="line">	float mass;</span><br><span class="line">	PVector location;</span><br><span class="line">	float G;</span><br><span class="line">	</span><br><span class="line">	Attractor() &#123;</span><br><span class="line">	location = new PVector(width / <span class="number">2</span>, height / <span class="number">2</span>);</span><br><span class="line">	mass = <span class="number">50</span>;</span><br><span class="line">	G = <span class="number">5</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	PVector attract(Mover m) &#123;</span><br><span class="line">	PVector force = PVector.sub(location, m.location);</span><br><span class="line">	float distance = force.mag();</span><br><span class="line">	distance = constrain(distance, <span class="number">10</span>, <span class="number">40</span>); //限制两者之间的距离</span><br><span class="line">	force.normalize();</span><br><span class="line">	float strength = (G * mass * m.mass) / (distance * distance);</span><br><span class="line">	force.mult(strength);</span><br><span class="line">	<span class="keyword">return</span> force;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	void display() &#123;</span><br><span class="line">	stroke(<span class="number">0</span>);</span><br><span class="line">	fill(<span class="number">255</span>);</span><br><span class="line">	ellipse(location.x, location.y, mass * <span class="number">2</span>, mass * <span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>作为一个重度“颜控”的程序员，热衷于实现一些炫酷、优雅或是有趣的视觉效果。Processing非常契合我的需求。之后会深入学习，争取做一些有意思的作品。</p>
]]></content>
      <tags>
        <tag>Processing</tag>
      </tags>
  </entry>
  <entry>
    <title>TimeLine自定义轨道</title>
    <url>/2021/01/24/tech/TimeLine1/</url>
    <content><![CDATA[<p>Unity中的TimeLine支持自定义轨道，一般需要新建三个（若需要处理混合则为四个）类。<a href="https://www.bilibili.com/video/BV1x7411P7J3">官方教学视频</a></p>
<a id="more"></a>

<h3 id="一、Track"><a href="#一、Track" class="headerlink" title="一、Track"></a>一、Track</h3><h4 id="1、用途"><a href="#1、用途" class="headerlink" title="1、用途"></a>1、用途</h4><p>首先需要定义一个轨道类，继承TrackAsset，它代表了时间轴内的轨道。<a href="https://docs.unity3d.com/cn/2018.1/ScriptReference/Timeline.TrackAsset.html">官方API</a></p>
<h4 id="2、代码示例"><a href="#2、代码示例" class="headerlink" title="2、代码示例"></a>2、代码示例</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">TrackColor(0.055f, 0.03f, 0.387f)</span>]</span><br><span class="line">[<span class="meta">TrackClipType(typeof(MyClip))</span>]</span><br><span class="line">[<span class="meta">TrackBindingType(typeof(Animator))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyTrack</span> : <span class="title">TrackAsset</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">int</span> blendingDuration = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> Playable <span class="title">CreatePlayable</span>(<span class="params">PlayableGraph graph, GameObject gameObject, TimelineClip clip</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> asset = clip.asset <span class="keyword">as</span> MyClip;</span><br><span class="line">        asset.duration = blendingDuration;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">base</span>.CreatePlayable(graph, gameObject, clip);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、轨道类可以被三种特性标签修饰"><a href="#3、轨道类可以被三种特性标签修饰" class="headerlink" title="3、轨道类可以被三种特性标签修饰"></a>3、轨道类可以被三种特性标签修饰</h4><ul>
<li><code>[TrackColor(float r, float g, float b)]</code>用于定义轨道的颜色，方便不同轨道之间的区分；</li>
<li><code>[TrackClipType(Type clipClass)]</code>用于指定在轨道中可创建的<code>PlayableAsset</code>类型，可以理解实现了轨道类型和片段类型之间的绑定，同一个轨道可以添加多种不同的片段类型，及可以有多个<code>TrackClipType</code>修饰同一个轨道类；</li>
<li><code>[TrackBindingType(Type type)]</code>用于指定轨道需要绑定到的对象类型，如示例中的<code>LookAtTrack</code>是用于控制某个角色上的头部动画，因此需要绑定一个角色的Animator组件。若改轨道不需要绑定特定对象，则不需要添加该标签。</li>
</ul>
<h4 id="4、常用方法"><a href="#4、常用方法" class="headerlink" title="4、常用方法"></a>4、常用方法</h4><ul>
<li><code>protected override Playable CreatePlayable(PlayableGraph graph, GameObject gameObject, TimelineClip clip)</code></li>
<li><code>protected override void OnCreateClip(TimelineClip clip)</code> 在新建片段时调用用于设置Clip的默认值。</li>
<li><code>public override Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount)</code>当片段之间支持混合时可添加该方法。</li>
</ul>
<h3 id="二、Asset"><a href="#二、Asset" class="headerlink" title="二、Asset"></a>二、Asset</h3><h4 id="1、用途-1"><a href="#1、用途-1" class="headerlink" title="1、用途"></a>1、用途</h4><p>接着定义一个继承<code>PlayableAsset</code>、实现接口<code>ITimelineClipAsset</code>的类，用于表示片段资源，该类中可以定义片段包含的字段，这些字段会暴露到Inspector中。</p>
<h4 id="2、代码示例-1"><a href="#2、代码示例-1" class="headerlink" title="2、代码示例"></a>2、代码示例</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClip</span> : <span class="title">PlayableAsset</span>, <span class="title">ITimelineClipAsset</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">string</span> content;</span><br><span class="line">	<span class="keyword">public</span> ExposedReference&lt;Transform&gt; target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> DialogueBehaviour template = <span class="keyword">new</span> MyBehaviour();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ClipCaps clipCaps</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">get</span> &#123; <span class="keyword">return</span> ClipCaps.None; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Playable <span class="title">CreatePlayable</span>(<span class="params">PlayableGraph graph, GameObject owner</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">		<span class="keyword">var</span> playable = ScriptPlayable&lt;MyBehaviour&gt;.Create(graph, template);</span><br><span class="line">		<span class="keyword">var</span> myBehaviour = playable.GetBehaviour();</span><br><span class="line">		myBehaviour.content = content;</span><br><span class="line">		myBehaviour.target = target;</span><br><span class="line">		<span class="keyword">return</span> playable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、常用方法"><a href="#3、常用方法" class="headerlink" title="3、常用方法"></a>3、常用方法</h4><p>通常该类中会重写<code>CreatePlayable()</code>方法，常用于实现该类和<code>Behaviour</code>类之间的数据传递，关于</p>
<p>ScriptPlayable 和 PlayableBehaviour的使用可参考<a href="https://docs.unity3d.com/cn/current/Manual/Playables-ScriptPlayable.html">ScriptPlayable 和 PlayableBehaviour - Unity 手册 </a></p>
<h3 id="三、Behaviour"><a href="#三、Behaviour" class="headerlink" title="三、Behaviour"></a>三、Behaviour</h3><h4 id="1、用途-2"><a href="#1、用途-2" class="headerlink" title="1、用途"></a>1、用途</h4><p>接着定义一个Behaviour类继承<code>PlayableBehaviour</code>用于描述片段中触发的行为。<a href="https://docs.unity3d.com/2017.1/Documentation/ScriptReference/Playables.PlayableBehaviour.html">官方API</a></p>
<h4 id="2、代码示例-2"><a href="#2、代码示例-2" class="headerlink" title="2、代码示例"></a>2、代码示例</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyBehaviour</span> : <span class="title">PlayableBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">bool</span> clipPlayed = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">bool</span> pauseScheduled = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> PlayableDirector director;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnPlayableCreate</span>(<span class="params">Playable playable</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        director = (playable.GetGraph().GetResolver() <span class="keyword">as</span> PlayableDirector);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnBehaviourPlay</span>(<span class="params">Playable playable, FrameData info</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!clipPlayed &amp;&amp; info.weight &gt; <span class="number">0f</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Application.isPlaying) pauseScheduled = <span class="literal">true</span>;</span><br><span class="line">            clipPlayed = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnBehaviourPause</span>(<span class="params">Playable playable, FrameData info</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pauseScheduled)</span><br><span class="line">        &#123;</span><br><span class="line">            pauseScheduled = <span class="literal">false</span>;</span><br><span class="line">            clipPlayed = <span class="literal">false</span>;</span><br><span class="line">            director.Pause();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、常用方法-1"><a href="#3、常用方法-1" class="headerlink" title="3、常用方法"></a>3、常用方法</h4><ul>
<li><code>PrepareFrame</code> 循环播放刷新时调用</li>
<li><code>OnBehaviourPlay</code> 进入该行为片段时调用</li>
<li><code>OnBehaviourPause</code> 退出该行为片段时调用</li>
<li><code>OnPlayableCreate</code> 创建时、编辑器模式选中Timeline时</li>
<li><code>OnGraphStart</code> 创建后、播放时</li>
<li><code>OnGraphStop</code> 停止时，编辑器模式选中其他对象时</li>
<li><code>OnPlayableDestroy</code> 同上，在停止后调用</li>
</ul>
<h3 id="四、Mixer"><a href="#四、Mixer" class="headerlink" title="四、Mixer"></a>四、Mixer</h3><p>若需要使轨道片段支持融合，则需要添加Mixer类，该类同样继承<code>PlayableBehaviour</code></p>
<h3 id="五、踩坑合集"><a href="#五、踩坑合集" class="headerlink" title="五、踩坑合集"></a>五、踩坑合集</h3><ul>
<li>Clip的遍历：Timeline没有提供快速定位到某一Clip的接口，要想定位只能遍历，而且要从轨道开始遍历，这让代码写起来非常恶心，需要嵌套多层循环。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">IEnumerable&lt;TimelineClip&gt; tempClips = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> playableAsset = director.playableAsset <span class="keyword">as</span> TimelineAsset;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> track <span class="keyword">in</span> playableAsset.GetOutputTracks())</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (track <span class="keyword">is</span> MyTrack &amp;&amp; !track.muted)</span><br><span class="line">	&#123;</span><br><span class="line">		tempClips = track.GetClips();</span><br><span class="line">		<span class="keyword">foreach</span> (<span class="keyword">var</span> clip <span class="keyword">in</span> tempClips)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (clip.asset <span class="keyword">is</span> MyClip b)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//...</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对场景中对象的引用需要通过<code>ExposedReference&lt;T&gt;</code>创建，否则绑定完成的引用无法被Unity保存。对应的调用则需要通过<code>Resolve(graph.GetResolver())</code>解析出对象。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ExposedReference&lt;Transform&gt; target;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Playable <span class="title">CreatePlayable</span>(<span class="params">PlayableGraph graph, GameObject owner</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> target = target.Resolve(graph.GetResolver());    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>C#</tag>
        <tag>Unity</tag>
        <tag>Timeline</tag>
      </tags>
  </entry>
  <entry>
    <title>一种拨轮动效</title>
    <url>/2020/09/28/tech/TimeWidget/</url>
    <content><![CDATA[<p>实现了一种拨轮动画效果，可以用于游戏中的倒计时、数值显示等。目前实现了初始化的动画效果。</p>
<a id="more"></a>

<p><video src="/image/TimeWidget.mov" controls="controls" style="max-width: 50%; display: block; margin-left: auto; margin-right: auto;"> your browser does not support the video tag </video></p>
<p><a href="https://github.com/Luciano-0/TimeWidget">Github地址</a></p>
]]></content>
      <tags>
        <tag>C#</tag>
        <tag>Unity</tag>
        <tag>动效</tag>
      </tags>
  </entry>
  <entry>
    <title>Timeline跳转过渡</title>
    <url>/2021/01/30/tech/Timeline2/</url>
    <content><![CDATA[<h3 id="一、Animation-Track的过渡"><a href="#一、Animation-Track的过渡" class="headerlink" title="一、Animation Track的过渡"></a>一、Animation Track的过渡</h3><h4 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h4><p>当运行到Clip中间时，角色动画会由Timeline接管，即播放AnimationClip中的动画，当运行到Clip之外时，若前后片段中的Animation Extrapolation有设置为Hold，则会保持对应帧的动作，若都为None则会将动画控制权移交给状态机，通常播放Idle的动作。</p>
<a id="more"></a>

<h4 id="2、问题"><a href="#2、问题" class="headerlink" title="2、问题"></a>2、问题</h4><p>通常在游戏的剧情对话中，用户点击可以跳转到下一段对话，此时会涉及到两个AnimationClip之间的跳转过渡，若直接跳转则会出现动作的突变，即上一动画还没有播放完，就会切到下一动画的开头，影响观感。因此需要进行过渡处理。</p>
<h4 id="3、解决方法"><a href="#3、解决方法" class="headerlink" title="3、解决方法"></a>3、解决方法</h4><p>要想实现自然的过渡就需要两个Clip之间的融合，目前实现的方案是在跳转时对未播放完的片段进行克隆，将其移到下一个片段的开头，Timeline就会对两个片段自动融合。需要注意的是，运行时克隆出来的片段在运行完后Timeline不会对其销毁，因此需要将这些克隆片段暂存起来，在合适的时候删除。</p>
<h4 id="4、代码"><a href="#4、代码" class="headerlink" title="4、代码"></a>4、代码</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AnimationTranstion</span>(<span class="params"><span class="keyword">int</span> to</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DeleteCloneClip(cloneAnimationClips);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> track <span class="keyword">in</span> animationClips)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!track.Value.TryGetValue(curSectionClip, <span class="keyword">out</span> _)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!cloneAnimationClips.TryGetValue(track.Key, <span class="keyword">out</span> _))</span><br><span class="line">            cloneAnimationClips[track.Key] = <span class="keyword">new</span> List&lt;TimelineClip&gt;();</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> clip <span class="keyword">in</span> track.Value[curSectionClip])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (clip.start &lt; director.time &amp;&amp; clip.end &gt; director.time)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> cloneClip = CloneTimelineAnimationClip(track.Key <span class="keyword">as</span> AnimationTrack, clip);</span><br><span class="line"></span><br><span class="line">                cloneClip.start = sectionClips[to].start - (director.time - clip.start);</span><br><span class="line">                TimelineClip nextClip = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    nextClip = animationClips[track.Key][sectionClips[to]][<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Exception e)</span><br><span class="line">                &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nextClip != <span class="literal">null</span> &amp;&amp; nextClip.start - sectionClips[to].start &lt;= clip.end - director.time)</span><br><span class="line">                    &#123;</span><br><span class="line">                        cloneClip.duration = director.time - clip.start + Mathf.Min(<span class="keyword">new</span>[]</span><br><span class="line">                        &#123;</span><br><span class="line">                            (<span class="keyword">float</span>) (clip.end - director.time),</span><br><span class="line">                            (<span class="keyword">float</span>) (nextClip.easeInDuration + nextClip.start - sectionClips[to].start)</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> cloneClip.duration = clip.duration;</span><br><span class="line"></span><br><span class="line">                    cloneAnimationClips[track.Key].Add(cloneClip);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> TimelineClip <span class="title">CloneTimelineAnimationClip</span>(<span class="params">AnimationTrack track, TimelineClip nativeClip</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cloneClip = track.CreateClip(nativeClip.animationClip);</span><br><span class="line">    cloneClip.start = nativeClip.start;</span><br><span class="line">    cloneClip.duration = nativeClip.duration;</span><br><span class="line">    cloneClip.easeInDuration = nativeClip.easeInDuration;</span><br><span class="line">    cloneClip.easeOutDuration = nativeClip.easeOutDuration;</span><br><span class="line">    cloneClip.clipIn = nativeClip.clipIn;</span><br><span class="line">    cloneClip.timeScale = nativeClip.timeScale;</span><br><span class="line">    cloneClip.blendInDuration = nativeClip.blendInDuration;</span><br><span class="line">    cloneClip.blendOutDuration = nativeClip.blendOutDuration;</span><br><span class="line">    cloneClip.blendInCurveMode = nativeClip.blendInCurveMode;</span><br><span class="line">    cloneClip.blendOutCurveMode = nativeClip.blendOutCurveMode;</span><br><span class="line">    <span class="keyword">return</span> cloneClip;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DeleteCloneClip</span>(<span class="params">Dictionary&lt;TrackAsset, List&lt;TimelineClip&gt;&gt; dictionary</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">foreach</span> (<span class="keyword">var</span> pair <span class="keyword">in</span> dictionary)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">foreach</span> (<span class="keyword">var</span> clip <span class="keyword">in</span> pair.Value)</span><br><span class="line">		&#123;</span><br><span class="line">			pair.Key.DeleteClip(clip);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	dictionary.Clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、Cinemachine-Track的过渡"><a href="#二、Cinemachine-Track的过渡" class="headerlink" title="二、Cinemachine Track的过渡"></a>二、Cinemachine Track的过渡</h3><h4 id="1、问题背景"><a href="#1、问题背景" class="headerlink" title="1、问题背景"></a>1、问题背景</h4><p>和Animation Track略有不同的是，Cinemachine Track在Clip之外会自动将相机控制权交给优先级最高的虚拟相机。</p>
<p>当Clip存在渐变过渡时，实际上是将优先权最高的相机位置和Clip绑定的相机位置进行融合。</p>
<h4 id="2、解决方法"><a href="#2、解决方法" class="headerlink" title="2、解决方法"></a>2、解决方法</h4><p>添加一个虚拟相机，将优先级设置为最高，用于缓存真实相机的位置。在发生跳转时，将此时真实相机的位置状态赋给该虚拟相机。跳转后就是该虚拟相机与下一片段的虚拟相机进行融合。</p>
<h4 id="3、代码"><a href="#3、代码" class="headerlink" title="3、代码"></a>3、代码</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> CinemachineVirtualCamera cineMachine;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CinemachineTranstion</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (director == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">var</span> playableAsset = director.playableAsset <span class="keyword">as</span> TimelineAsset;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> track <span class="keyword">in</span> playableAsset.GetOutputTracks())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> binding = director.GetGenericBinding(track);</span><br><span class="line">        <span class="keyword">if</span> (!(track <span class="keyword">is</span> CinemachineTrack &amp;&amp; !track.muted &amp;&amp; binding != <span class="literal">null</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Camera camera = (binding <span class="keyword">as</span> CinemachineBrain).gameObject.GetComponent&lt;Camera&gt;();</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> clip <span class="keyword">in</span> track.GetClips())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (clip.start &lt;= director.time &amp;&amp; clip.end &gt;= director.time)</span><br><span class="line">            &#123;</span><br><span class="line">                cineMachine.transform.position = camera.transform.position;</span><br><span class="line">                cineMachine.transform.rotation = camera.transform.rotation;</span><br><span class="line">                cineMachine.transform.localScale = camera.transform.localScale;</span><br><span class="line">                LensSettings lens = cineMachine.State.Lens;</span><br><span class="line">                lens.OrthographicSize = camera.orthographicSize;</span><br><span class="line">                lens.NearClipPlane = camera.nearClipPlane;</span><br><span class="line">                lens.FarClipPlane = camera.farClipPlane;</span><br><span class="line">                lens.FieldOfView = camera.fieldOfView;</span><br><span class="line">                cineMachine.m_Lens = lens;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>C#</tag>
        <tag>Unity</tag>
        <tag>Timeline</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/09/12/tech/hello-world/</url>
    <content><![CDATA[<p>Hello World！</p>
]]></content>
  </entry>
  <entry>
    <title>山河满目，既往不咎</title>
    <url>/2020/01/10/photo/20200110-WestLake/</url>
    <content><![CDATA[<p>2019年最后一天，于西湖。</p>
<img data-src="/image/6-1.jpg" alt=" " style="zoom:30%;"/>

<a id="more"></a>

<img data-src="/image/6-2.jpg" alt=" " style="zoom:30%;"/>

<img data-src="/image/6-3.jpg" alt=" " style="zoom:30%;"/>

<img data-src="/image/6-4.jpg" alt=" " style="zoom:30%;"/>

<img data-src="/image/6-5.jpg" alt=" " style="zoom:30%;"/>

<img data-src="/image/6-6.jpg" alt=" " style="zoom:30%;"/>]]></content>
      <tags>
        <tag>photos</tag>
        <tag>胶片</tag>
      </tags>
  </entry>
  <entry>
    <title>Anconda常用命令</title>
    <url>/2020/09/12/tech/text/</url>
    <content><![CDATA[<ul>
<li>conda当前版本</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda -V</span><br></pre></td></tr></table></figure>

<ul>
<li>列举当前安装的包</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda list</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<ul>
<li>conda基本信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda info</span><br></pre></td></tr></table></figure>

<ul>
<li>当前存在的虚拟环境</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda env list</span><br></pre></td></tr></table></figure>

<ul>
<li>检查更新</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda update conda</span><br></pre></td></tr></table></figure>

<ul>
<li>创建虚拟环境</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda create --name your_env_name python&#x3D;3.7</span><br></pre></td></tr></table></figure>

<ul>
<li>激活虚拟环境</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda activate your_env_name</span><br></pre></td></tr></table></figure>

<ul>
<li>关闭虚拟环境</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda deactivate</span><br></pre></td></tr></table></figure>

<ul>
<li>安装包</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda install package_name</span><br></pre></td></tr></table></figure>

<ul>
<li>删除包</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda remove package_name</span><br></pre></td></tr></table></figure>

<ul>
<li>删除虚拟环境</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda remove --name your_env_name --all</span><br></pre></td></tr></table></figure>

<ul>
<li>添加源</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda config --add channel_urls</span><br></pre></td></tr></table></figure>

<ul>
<li>换回默认源</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda config --remove-key channels</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>故乡</title>
    <url>/2020/10/11/photo/20201005-hometown/</url>
    <content><![CDATA[<p>故乡，大概是写在每个人灵魂最深处的底层代码。</p>
<p>越长大，在家的日子就越少。曾经熟悉的地方，那些个常去的影院，洒过汗水的球场，躲过雨的屋檐，一不留神就变了模样，甚至，一晃眼就成了一片废墟，再也回不来了。</p>
<p>这小小的一方城池啊，承载着太多回忆。因为这片土地上有我们在意的人儿，发生过许许多多与我们有关的事，这土地上的钢筋混凝土才有了温度，被我们惦记着，并亲切地称之为故乡。</p>
<a id="more"></a>

<img data-src="/image/3-1.jpg" alt="1" style="zoom:30%;"/>

<img data-src="/image/3-2.jpg" alt="2" style="zoom:30%;"/>

<img data-src="/image/3-3.jpg" alt="3" style="zoom:30%;"/>    

<img data-src="/image/3-4.jpg" alt="4" style="zoom:30%;"/>

<img data-src="/image/3-5.jpg" alt="5" style="zoom:30%;"/>

<img data-src="/image/3-6.jpg" alt="6" style="zoom:30%;"/>

<img data-src="/image/3-7.jpg" alt="7" style="zoom:30%;"/>

<img data-src="/image/3-8.jpg" alt="8" style="zoom:30%;"/>]]></content>
      <tags>
        <tag>photos</tag>
        <tag>胶片</tag>
      </tags>
  </entry>
  <entry>
    <title>关于校园的一些碎片</title>
    <url>/2020/01/01/photo/20200101-school/</url>
    <content><![CDATA[<img data-src="/image/4-1.jpg" alt="天台" style="zoom:16%;"/>

<a id="more"></a>

<img data-src="/image/4-2.jpg" alt="红黄蓝" style="zoom:30%;"/>

<img data-src="/image/4-4.jpg" alt="最爱玉泉午后的光影" style="zoom:30%;"/>

<img data-src="/image/4-5.jpg" alt="玉泉某个角落" style="zoom:30%;"/>

<img data-src="/image/4-6.jpg" alt="不知道是什么楼" style="zoom:30%;"/>

<img data-src="/image/4-7.jpg" alt="祖国万岁" style="zoom:30%;"/>

<img data-src="/image/4-8.jpg" alt="请爱护光缆" style="zoom:30%;"/>

<img data-src="/image/4-9.jpg" alt="紫金港的鹅鹅鹅" style="zoom:16%;"/>

<img data-src="/image/4-10.jpg" alt="你瞅啥" style="zoom:16%;"/>]]></content>
      <tags>
        <tag>photos</tag>
        <tag>胶片</tag>
      </tags>
  </entry>
  <entry>
    <title>月亮碎了，于是星星亮了</title>
    <url>/2020/04/30/photo/20200430-star/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>手牵手一步两步三步四步望着天    </p>
<p>看星星一颗两颗三颗四颗连成线</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<img data-src= "/image/2-1.jpg" alt="1" style="zoom:16%;"/>

<a id="more"></a>

<img data-src= "/image/2-2.jpg" alt="2" style="zoom:16%;"/>

<img data-src= "/image/2-3.jpg" alt="3" style="zoom:16%;"/>

<img data-src= "/image/2-4.jpg" alt="4" style="zoom:16%;"/>

<img data-src= "/image/2-5.jpg" alt="5" style="zoom:16%;"/>

<img data-src= "/image/2-6.jpg" alt="6" style="zoom:16%;"/>

]]></content>
      <tags>
        <tag>photos</tag>
      </tags>
  </entry>
  <entry>
    <title>那些年追过的展（持续更新）</title>
    <url>/2020/10/31/photo/20201031-gallery/</url>
    <content><![CDATA[<img data-src="/image/5-1.jpg" alt="🌊" style="zoom:30%;"/>

<a id="more"></a>

<img data-src="/image/5-2.jpg" alt="早安打工人！" style="zoom:30%;"/>

<img data-src="/image/5-3.jpg" alt="西岸美术馆的长梯" style="zoom:30%;"/>

<img data-src="/image/5-4.jpg" alt="Wheel" style="zoom:30%;"/>

<img data-src="/image/5-5.jpg" alt="Plane" style="zoom:30%;"/>

<img data-src="/image/5-6.jpg" alt="月食" style="zoom:30%;"/>

<img data-src="/image/5-7.jpg" alt="最美二叉树？" style="zoom:30%;"/>]]></content>
      <tags>
        <tag>photos</tag>
      </tags>
  </entry>
  <entry>
    <title>毕业那些事</title>
    <url>/2020/10/11/photo/20200630-graduate/</url>
    <content><![CDATA[<p>毕业，在杭州的雨季中悄然而至。</p>
<p>2020年的毕业季，号称史上最难毕业季。疫情之下，校园紧闭，连最后的相聚也显得格外仓促。</p>
<a id="more"></a>

<p>雨后的校园，就会长出三三两两的穿着学位服拍照的人们，趁着一两片弥足珍贵的阳光，定格校园中最后的时光。</p>
<img data-src="/image/1-1.jpg" alt="最后一课" style="zoom:16%;"/>

<p>平日里，我是一个没心没肺的人，但到了离别的时候，总想着，让时间过得再慢一些，还想和这些可爱的人儿多说一些话。</p>
<p>高中毕业时，似乎内心全乎是高考结束的欣喜，全然没有离别的伤感。大概是因为喜欢的人还在身边，要好的哥们还住对面，大家奔赴五湖四海，但我们来自同一个地方，相聚还容易。</p>
<p>但今时不同往日。或许是因为我们来自五湖四海，匆匆四年又即将奔赴五湖四海，又或许，是因为自己也即将离开熟悉的城市，成为异乡人。</p>
<p>在未来的某一刻，可能会突然意识到，有些人，此刻说了再见，这辈子就真的再也不见了。</p>
<img data-src="/image/1-2.jpg" alt="毕业前再去瞅瞅西湖" style="zoom:25%;"/>

<p>我们不能奢求有人可以一直陪我们走下去，有些人出现，就是在人生中陪我们走一段，这一段我们一起过得精彩，就足矣。<br>岁月匆匆，惟愿总相逢。</p>
]]></content>
      <tags>
        <tag>photos</tag>
      </tags>
  </entry>
  <entry>
    <title>追夕阳的日子</title>
    <url>/2020/10/31/photo/20201031-sun/</url>
    <content><![CDATA[<p>秋分一过，白天以肉眼可见的速度缩短。平日里七点下班，只能和星星月亮打个照面。</p>
<p>可幸的是，今年的秋天格外长，西伯利亚的寒风迟迟没有吹来，好让我有足够多的时间去感受秋日午后的温柔。</p>
<img data-src="/image/7-1.jpg" alt=" " style="zoom:30%;"/>

<a id="more"></a>

<p>揣上相机，骑个单车，打开杰伦的歌单列表循环，去把陌生城市的大街小巷都溜达一遍。</p>
<img data-src="/image/7-2.jpg" alt=" " style="zoom:30%;"/>

<p>过了三点，太阳也开始打盹，像极了下班前提前开始摸鱼的我们。阳光渐渐向着长波段偏移，这时，情况就变得焦急起来。 光影瞬息万变， 每一次快门可不再像原来那么从容。</p>
<img data-src="/image/7-3.jpg" alt=" " style="zoom:40%;"/>

<img data-src="/image/7-4.jpg" alt=" " style="zoom:30%;"/>

<p>最后一缕阳光总是最珍贵的，向着西边的方向，以高中时赶早自习的速度，去追赶那一片在高楼间透出来的夕阳。不过，追不上也没有关系，看到那渐变的天空吗，那是老天爷对勤奋小孩额外的馈赠。</p>
<img data-src="/image/7-5.jpg" alt=" " style="zoom:30%;"/>

<img data-src="/image/7-6.jpg" alt=" " style="zoom:30%;"/>

<p>想起高中作文里常写的老套的句子：看日出日落，云卷云舒。没想到在退休前还有机会过一段这样的日子，没有眼前的苟且，也没有诗和远方。但我自由自在，做着自己喜欢的事，在进步的同时还能有时间可以浪费。</p>
<img data-src="/image/7-7.jpg" alt=" " style="zoom:30%;"/>

<img data-src="/image/7-8.jpg" alt=" " style="zoom:30%;"/>

<p>我永这会记得那个追着夕阳跑的少年，那份中二的浪漫，且珍惜。</p>
]]></content>
      <tags>
        <tag>photos</tag>
        <tag>胶片</tag>
      </tags>
  </entry>
  <entry>
    <title>下一站，南京东路站</title>
    <url>/2021/02/23/photo/20210223-TheBond/</url>
    <content><![CDATA[<img data-src="/image/8-1.jpg" alt=" " style="zoom:30%;"/>

<a id="more"></a>

<img data-src="/image/8-2.jpg" alt=" " style="zoom:30%;"/>

<img data-src="/image/8-3.jpg" alt=" " style="zoom:30%;"/>

<img data-src="/image/8-4.jpg" alt=" " style="zoom:30%;"/>

<img data-src="/image/8-5.jpg" alt=" " style="zoom:30%;"/>

<img data-src="/image/8-6.jpg" alt=" " style="zoom:30%;"/>

<img data-src="/image/8-7.jpg" alt=" " style="zoom:30%;"/>

<img data-src="/image/8-8.jpg" alt=" " style="zoom:30%;"/>

<img data-src="/image/8-9.jpg" alt=" " style="zoom:30%;"/>

<img data-src="/image/8-10.jpg" alt=" " style="zoom:30%;"/>

<img data-src="/image/8-11.jpg" alt=" " style="zoom:30%;"/>

<img data-src="/image/8-12.jpg" alt=" " style="zoom:30%;"/>

<img data-src="/image/8-13.jpg" alt=" " style="zoom:30%;"/>]]></content>
      <tags>
        <tag>photos</tag>
        <tag>胶片</tag>
      </tags>
  </entry>
  <entry>
    <title>有时也可以换个角度看世界</title>
    <url>/2021/04/20/photo/20210420-Dji/</url>
    <content><![CDATA[<img data-src= "/image/12-1.jpg" alt="第一次试飞" style="zoom:30%;"/>

<a id="more"></a>

<img data-src= "/image/12-2.jpg" alt="去了有名的“老法师桥”" style="zoom:30%;"/>

<img data-src= "/image/12-3.jpg" alt="第一次尝试黑金色调" style="zoom:30%;"/>

<img data-src= "/image/12-4.jpg" alt="还有冰蓝色调" style="zoom:30%;"/>

<img data-src= "/image/12-5.jpg" alt="空中俯瞰夜上海" style="zoom:30%;"/>

<img data-src= "/image/12-6.jpg" alt="第二次试飞" style="zoom:50%;"/>

<img data-src= "/image/12-7.jpg" alt="杨浦大桥" style="zoom:50%;"/>

<img data-src= "/image/12-8.jpg" alt="全景" style="zoom:50%;"/>

<img data-src= "/image/12-9.jpg" alt="熟悉的浦阳江" style="zoom:30%;"/>

<img data-src= "/image/12-10.jpg" alt="对岸的绿皮火车" style="zoom:30%;"/>

<img data-src= "/image/12-11.jpg" alt="不知通往何方" style="zoom:30%;"/>

<img data-src= "/image/12-12.jpg" alt="佘山" style="zoom:30%;"/>

<img data-src= "/image/12-13.jpg" alt="山顶的圣母教堂" style="zoom:30%;"/>

<img data-src= "/image/12-14.jpg" alt="日落时分" style="zoom:30%;"/>

<img data-src= "/image/12-15.jpg" alt="加一个胶片滤镜" style="zoom:30%;"/>

<img data-src= "/image/12-16.jpg" alt="喜欢宽幅带来的电影感" style="zoom:30%;"/>

]]></content>
      <tags>
        <tag>photos</tag>
        <tag>航拍</tag>
      </tags>
  </entry>
  <entry>
    <title>今日：阴有阵雨</title>
    <url>/2021/02/28/photo/20210228-RainyShangHai/</url>
    <content><![CDATA[<img data-src="/image/10-7.jpg" alt=" " style="zoom:30%;"/>

<a id="more"></a>

<img data-src="/image/10-1.JPG" alt=" " style="zoom:30%;"/>

<img data-src="/image/10-2.JPG" alt=" " style="zoom:30%;"/>

<img data-src="/image/10-3.jpg" alt=" " style="zoom:30%;"/>

<img data-src="/image/10-4.jpg" alt=" " style="zoom:30%;"/>

<img data-src="/image/10-5.jpg" alt=" " style="zoom:30%;"/>

<img data-src="/image/10-6.jpg" alt=" " style="zoom:30%;"/>

<img data-src="/image/10-8.jpg" alt=" " style="zoom:30%;"/>

<img data-src="/image/10-9.jpg" alt=" " style="zoom:30%;"/>

<img data-src="/image/10-10.jpg" alt=" " style="zoom:30%;"/>

<img data-src="/image/10-11.jpg" alt=" " style="zoom:30%;"/>

<img data-src="/image/10-12.jpg" alt=" " style="zoom:30%;"/>

]]></content>
      <tags>
        <tag>photos</tag>
      </tags>
  </entry>
  <entry>
    <title>避世岛屿——横沙</title>
    <url>/2021/04/05/photo/20210405-HengSha/</url>
    <content><![CDATA[<img data-src= "/image/11-1.jpg" alt="1" style="zoom:30%;"/>

<a id="more"></a>

<img data-src= "/image/11-2.jpg" alt="2" style="zoom:30%;"/>

<img data-src= "/image/11-3.jpg" alt="3" style="zoom:30%;"/>

<img data-src= "/image/11-4.jpg" alt="4" style="zoom:30%;"/>

<img data-src= "/image/11-5.jpg" alt="5" style="zoom:30%;"/>

<img data-src= "/image/11-6.jpg" alt="6" style="zoom:30%;"/>

<img data-src= "/image/11-7.jpg" alt="7" style="zoom:30%;"/>

<img data-src= "/image/11-8.jpg" alt="8" style="zoom:30%;"/>

<img data-src= "/image/11-9.jpg" alt="9" style="zoom:30%;"/>

<img data-src= "/image/11-10.jpg" alt="10" style="zoom:30%;"/>

]]></content>
      <tags>
        <tag>photos</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏人工智能的移动</title>
    <url>/2022/01/23/tech/AIMovement/</url>
    <content><![CDATA[<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><p>游戏中的人工智能指拥有决策能力的智能体，会对环境的改变作出相应的决策。其中，移动是智能体最基本也是最通用的行为。</p>
<p>智能体的移动可以分为三个环节：</p>
<ul>
<li><strong>行为选择</strong>：该部分负责选定目标、制定计划。它来告诉我们“到这来”和“做好A、B，然后做C”。</li>
<li><strong>操控</strong>：该环节负责计算运动数据，根据选择的行为计算得到一个操控力，它决定智能体往哪儿移动以及如何快速移动。</li>
<li><strong>移动</strong>：主要表现智能体运动的机械因素，即控制智能体的移动方式。比如，人和汽车有不同的移动方式，虽然他们具有同样的意向，收到相同的操控力，但是最终的移动表现是完全不同的。</li>
</ul>
<a id="more"></a>

<h2 id="2-模型建立：MovingEntity"><a href="#2-模型建立：MovingEntity" class="headerlink" title="2. 模型建立：MovingEntity"></a>2. 模型建立：MovingEntity</h2><p>在开始之前首先建立一个最基本的移动智能体的模型，即确定下移动的环节。</p>
<p>通常一个移动的智能体具有以下属性：</p>
<ul>
<li>位置：position</li>
<li>方向：rotation</li>
<li>质量：mass</li>
<li>速度：velocity</li>
<li>操控力：force</li>
<li>最大速度：maxSpeed</li>
<li>最大操控力：maxForce</li>
<li>最大转动速率：maxTurnRate</li>
</ul>
<p>MovingEntity类中需要有Update()方法来每帧更新智能体的物理状态，代码如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (mass == <span class="number">0</span>) mass = <span class="number">1</span>;</span><br><span class="line">		Velocity = Force / mass * Time.deltaTime + Velocity;</span><br><span class="line">		<span class="keyword">if</span> (Velocity.sqrMagnitude &gt; maxSpeed * maxSpeed)</span><br><span class="line">      	Velocity = Velocity.normalized * maxSpeed;</span><br><span class="line">		transform.position += Velocity * Time.deltaTime;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> fn = Velocity.normalized;</span><br><span class="line">		<span class="keyword">var</span> vn = transform.forward;</span><br><span class="line">		<span class="keyword">if</span> (fn == <span class="keyword">default</span>) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">var</span> angle = Vector3.Angle(fn, vn);</span><br><span class="line">		<span class="keyword">if</span> (angle &lt; <span class="number">5</span>) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">var</span> axis = Vector3.Cross(fn, vn);</span><br><span class="line">		transform.Rotate(axis, -maxTurnRate * Time.deltaTime, Space.World);</span><br><span class="line">		transform.Rotate(transform.forward * rotationSpeed * Time.deltaTime, Space.World);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-个体行为"><a href="#3-个体行为" class="headerlink" title="3. 个体行为"></a>3. 个体行为</h2><p>接下来是最关键的部分，根据不同的行为计算需要施加的操控力。在分析各种行为过程中，我们总是遵循一个公式：</p>
<ul>
<li><strong>操控力 = 预期速度 - 当前速度</strong></li>
</ul>
<h3 id="3-1-Seek（靠近）"><a href="#3-1-Seek（靠近）" class="headerlink" title="3.1 Seek（靠近）"></a>3.1 Seek（靠近）</h3><ul>
<li>预期速度：这个速度为智能体在理想状态下到达目标位置所需的速度，方向为智能体到目标位置的向量，大小为最大速度。</li>
<li>所需操控力：方向为 (预期速度-当前速度)，大小为最大操控力大小。</li>
</ul>
<img data-src="/Users/luciano/Library/Mobile Documents/com~apple~CloudDocs/Blog/markdown/游戏人工智能-Movement.assets/图片1.png" alt="图片1" style="zoom:50%;" />

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">Seek</span>(<span class="params"><span class="keyword">this</span> MovingEntity entity, Vector3 target</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">var</span> dis = target - entity.transform.position;</span><br><span class="line">		<span class="keyword">var</span> needVelocity = dis.normalized * entity.maxSpeed;</span><br><span class="line">		<span class="keyword">var</span> deltaVelocity = needVelocity - entity.Velocity;</span><br><span class="line">		<span class="keyword">return</span> deltaVelocity.normalized * entity.maxForce;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img data-src="/Users/luciano/Library/Mobile Documents/com~apple~CloudDocs/Blog/markdown/游戏人工智能-Movement.assets/ezgif-7-db1cb3b24cef.gif" alt="ezgif-7-db1cb3b24cef" style="zoom:50%;" />

<h3 id="3-2-Flee（远离）"><a href="#3-2-Flee（远离）" class="headerlink" title="3.2 Flee（远离）"></a>3.2 Flee（远离）</h3><ul>
<li>预期速度与Seek正好相反。</li>
<li>可以进行适当调整，如当目标进入到一定范围内才产生远离的操控力。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">Flee</span>(<span class="params"><span class="keyword">this</span> MovingEntity entity, Vector3 target, <span class="keyword">float</span> keepDistance</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pos = entity.transform.position;</span><br><span class="line">    <span class="keyword">if</span> ((pos - target).sqrMagnitude &gt;= keepDistance * keepDistance)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (entity.Velocity.sqrMagnitude &lt; <span class="number">0.1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            entity.Stop();</span><br><span class="line">            <span class="keyword">return</span> Vector3.zero;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> entity.Velocity.normalized * <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> needVelocity = (pos - target).normalized * entity.maxSpeed;</span><br><span class="line">    <span class="keyword">var</span> deltaVelocity = needVelocity - entity.Velocity;</span><br><span class="line">    <span class="keyword">return</span> deltaVelocity.normalized * entity.maxForce;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-3-Arrive（抵达）"><a href="#3-3-Arrive（抵达）" class="headerlink" title="3.3 Arrive（抵达）"></a>3.3 Arrive（抵达）</h3><ul>
<li>与Seek不同，Arrive可以实现减速并停在目标位置。当与目标距离大于阈值时算法与Seek相同，当距离小于阈值时需要进行减速。</li>
<li>进入阈值时的预期速度：方向为智能体到目标位置的向量，大小与距离的1/2次幂成正比。</li>
<li>所需操控力：方向为 (预期速度-当前速度)，大小为最大操控力大小。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">Arrive</span>(<span class="params"><span class="keyword">this</span> MovingEntity entity, Vector3 target, <span class="keyword">float</span> slowDownDis = <span class="number">10</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> toTarget = target - entity.transform.position;</span><br><span class="line">    <span class="keyword">var</span> dis = toTarget.magnitude;</span><br><span class="line">    <span class="keyword">if</span> (dis &gt; slowDownDis) <span class="keyword">return</span> entity.Seek(target);</span><br><span class="line">    <span class="keyword">if</span> (dis &gt; <span class="number">0.1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> needSpeed = (<span class="keyword">float</span>)Math.Sqrt(<span class="number">2</span> * entity.maxForce / entity.mass * dis);</span><br><span class="line">        <span class="keyword">var</span> needVelocity = toTarget.normalized * needSpeed;</span><br><span class="line">        <span class="keyword">return</span> (needVelocity - entity.Velocity).normalized * entity.maxForce;</span><br><span class="line">    &#125;</span><br><span class="line">    entity.Stop();</span><br><span class="line">    <span class="keyword">return</span> Vector3.zero;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>![ezgif-7-97cf6dcdebbf](/Users/luciano/Library/Mobile Documents/com<del>apple</del>CloudDocs/Blog/markdown/游戏人工智能-Movement.assets/ezgif-7-97cf6dcdebbf.gif)</p>
<h3 id="3-4-Pursuit（追逐）"><a href="#3-4-Pursuit（追逐）" class="headerlink" title="3.4 Pursuit（追逐）"></a>3.4 Pursuit（追逐）</h3><ul>
<li>在追逐目标时，我们通常不会直接向目标的当前位置跑，而是会预测目标未来的位置，向预测的位置跑，期间不断通过调整来缩短差距。</li>
<li>预测目标位置的算法可以变得很复杂，但我们可以做个折衷的选择，在保证足够的精度的同时又不会消耗过多的性能。</li>
<li>我们主要要计算的就是追上的位置距离当前目标的位置有多远，这个距离与当前自己与目标的距离成正比，与目标速度的二次幂成正比，与自己速度的二次幂成反比。</li>
<li>此外，需要考虑一种特殊情况，当目标朝向自己跑时，这时候不需要预测位置，直接朝向目标当前位置跑就能追上了。</li>
</ul>
<img data-src="/Users/luciano/Library/Mobile Documents/com~apple~CloudDocs/Blog/markdown/游戏人工智能-Movement.assets/图片3.png" alt="图片3" style="zoom:50%;" />

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">Pursuit</span>(<span class="params"><span class="keyword">this</span> MovingEntity entity, MovingEntity target, <span class="keyword">float</span> keepDistance = <span class="number">0.1f</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dir = entity.transform.position - target.transform.position;</span><br><span class="line">    <span class="comment">// 追到目标后停止</span></span><br><span class="line">    <span class="keyword">if</span> (dir.sqrMagnitude &lt;= keepDistance * keepDistance)</span><br><span class="line">    &#123;</span><br><span class="line">        entity.Stop();</span><br><span class="line">        <span class="keyword">return</span> Vector3.zero;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当目标朝向自己时，直接向目标当前位置移动</span></span><br><span class="line">    <span class="keyword">if</span> (Vector3.Angle(dir, target.transform.forward) &lt; <span class="number">20</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Seek(entity, target.transform.position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当目标在向其他方向移动时，需要预判目标一段时间后的位置。</span></span><br><span class="line">    <span class="keyword">var</span> tarSpeed = target.Velocity.magnitude;</span><br><span class="line">    <span class="keyword">var</span> lookAheadDis = dir.magnitude * tarSpeed / entity.maxSpeed;</span><br><span class="line">    <span class="keyword">var</span> tarPos = target.transform.position + target.Velocity.normalized * lookAheadDis;</span><br><span class="line">    <span class="keyword">return</span> entity.Seek(tarPos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img data-src="/Users/luciano/Library/Mobile Documents/com~apple~CloudDocs/Blog/markdown/游戏人工智能-Movement.assets/ezgif-7-50d90fbb5e2c.gif" alt="ezgif-7-50d90fbb5e2c" style="zoom:50%;" />

<h3 id="3-5-Evade-逃避"><a href="#3-5-Evade-逃避" class="headerlink" title="3.5 Evade(逃避)"></a>3.5 Evade(逃避)</h3><ul>
<li>和追逐类似，只是方向相反，且不用检查是否正面。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">Evade</span>(<span class="params"><span class="keyword">this</span> MovingEntity entity, MovingEntity target, <span class="keyword">float</span> keepDistance</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dir = entity.transform.position - target.transform.position;</span><br><span class="line">    <span class="keyword">var</span> tarSpeed = target.Velocity.magnitude;</span><br><span class="line">    <span class="keyword">var</span> lookAheadDis = dir.magnitude * tarSpeed / entity.maxSpeed;</span><br><span class="line">    <span class="keyword">var</span> tarPos = target.transform.position + target.Velocity.normalized * lookAheadDis;</span><br><span class="line">    <span class="keyword">return</span> entity.Flee(tarPos, keepDistance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-6-Wander（徘徊）"><a href="#3-6-Wander（徘徊）" class="headerlink" title="3.6 Wander（徘徊）"></a>3.6 Wander（徘徊）</h3><ul>
<li><strong>定义：</strong>产生一个操控力，使智能体在场景内随机移动。</li>
<li><strong>两个错误（欠优）的思路：</strong>1.使用普通的随机算法每帧都计算一个随机的驱动力：因为随机算法取到的随机数不是连续的，所以无法实现持续的驱动力变化，会产生抖动。2.使用Perlin噪声，可以产生连续的转弯，但是性能开销较大。</li>
<li><strong>Reynolds的解决方案：</strong>在智能体前端突出一个圆圈，目标被限制在该圆圈上。每帧给目标添加一个随机的位移，来产生一个随机但连续的操控力。通过控制圆圈的半径、圆圈到智能体的距离以及每帧随机位移的大小，就能产生各种形式的随机运动。</li>
<li>三维空间中，智能体的目标就改成限制在一个球体上。</li>
</ul>
<img data-src="/Users/luciano/Library/Mobile Documents/com~apple~CloudDocs/Blog/markdown/游戏人工智能-Movement.assets/图片5.png" alt="图片5" style="zoom:50%;" />

<p>![图片6](/Users/luciano/Library/Mobile Documents/com<del>apple</del>CloudDocs/Blog/markdown/游戏人工智能-Movement.assets/图片6.png)</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">Wander</span>(<span class="params"><span class="keyword">this</span> MovingEntity entity, <span class="keyword">float</span> wanderRadius, <span class="keyword">float</span> wanderDistance, <span class="keyword">float</span> wanderJitter,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">bool</span> limit = <span class="literal">true</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    entity.WanderTarget += <span class="keyword">new</span> Vector3(Random.Range(<span class="number">-1</span> * wanderJitter, wanderJitter),</span><br><span class="line">        Random.Range(<span class="number">-1</span> * wanderJitter, wanderJitter), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">var</span> limitParam = limit ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> wanderCirclePoint = entity.Velocity.normalized * wanderDistance + entity.transform.position * limitParam;</span><br><span class="line">    entity.WanderTarget = wanderCirclePoint + wanderRadius * (entity.WanderTarget - wanderCirclePoint).normalized;</span><br><span class="line">    <span class="keyword">return</span> entity.Seek(entity.WanderTarget);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img data-src="/Users/luciano/Library/Mobile Documents/com~apple~CloudDocs/Blog/markdown/游戏人工智能-Movement.assets/ezgif-7-7bf95b052761.gif" alt="ezgif-7-7bf95b052761" style="zoom:67%;" />

<img data-src="/Users/luciano/Library/Mobile Documents/com~apple~CloudDocs/Blog/markdown/游戏人工智能-Movement.assets/ezgif-7-8eb03b0523a4.gif" alt="ezgif-7-8eb03b0523a4" style="zoom:67%;" />

<h3 id="3-7-Interpose（插入）"><a href="#3-7-Interpose（插入）" class="headerlink" title="3.7 Interpose（插入）"></a>3.7 Interpose（插入）</h3><ul>
<li><strong>定义：</strong>产生一个操控力，控制智能体移动到两个智能体的中点，可以用于运动员截球，保镖保护老板等行为。</li>
<li><strong>实现方法：</strong><ul>
<li>计算智能体移动到当前两个目标连线中点需要的时间t。</li>
<li>计算t时间后两个目标所在的位置。</li>
<li>连线中点就是智能体的目标位置，使用Arrive移向它。</li>
</ul>
</li>
</ul>
<img data-src="/Users/luciano/Library/Mobile Documents/com~apple~CloudDocs/Blog/markdown/游戏人工智能-Movement.assets/图片4.png" alt="图片4" style="zoom:50%;" />

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">Interpose</span>(<span class="params"><span class="keyword">this</span> MovingEntity entity, MovingEntity targetA, MovingEntity targetB</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> targetAPos = targetA.transform.position;</span><br><span class="line">    <span class="keyword">var</span> targetBPos = targetB.transform.position;</span><br><span class="line">    <span class="keyword">var</span> centerNow = (targetAPos + targetBPos) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">var</span> time = (entity.transform.position - centerNow).magnitude / entity.maxSpeed;</span><br><span class="line">    <span class="keyword">var</span> targetAPosPre = targetAPos + targetA.Velocity * time;</span><br><span class="line">    <span class="keyword">var</span> targetBPosPre = targetBPos + targetB.Velocity * time;</span><br><span class="line">    <span class="keyword">return</span> entity.Arrive((targetAPosPre + targetBPosPre) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img data-src="/Users/luciano/Library/Mobile Documents/com~apple~CloudDocs/Blog/markdown/游戏人工智能-Movement.assets/ezgif-7-50c0901241f0.gif" alt="ezgif-7-50c0901241f0" style="zoom: 67%;" />

<h3 id="3-8-Offset-Pursuit（保持一定偏移的追逐）"><a href="#3-8-Offset-Pursuit（保持一定偏移的追逐）" class="headerlink" title="3.8 Offset Pursuit（保持一定偏移的追逐）"></a>3.8 Offset Pursuit（保持一定偏移的追逐）</h3><ul>
<li><strong>定义：</strong>在追逐的同时保持智能体与目标之间有一个指定的偏移。可用于体育比赛中的盯防、实现战斗编队、空中飞船对接等。</li>
<li><strong>实现思路：</strong>与追逐类似，需要预测下一个带偏移的目标位置，然后用Arrive接近该位置（不能用Seek）。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">OffsetPursuit</span>(<span class="params"><span class="keyword">this</span> MovingEntity entity, MovingEntity target, Vector3 offset</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dir = entity.transform.position - target.transform.position;</span><br><span class="line">    <span class="keyword">var</span> tarSpeed = target.Velocity.magnitude;</span><br><span class="line">    <span class="keyword">var</span> lookAheadDis = dir.magnitude * tarSpeed / entity.maxSpeed;</span><br><span class="line">    <span class="keyword">var</span> tarPos = target.transform.position + target.Velocity.normalized * lookAheadDis +</span><br><span class="line">                 target.transform.TransformVector(offset);</span><br><span class="line">    <span class="keyword">return</span> entity.Arrive(tarPos, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img data-src="/Users/luciano/Library/Mobile Documents/com~apple~CloudDocs/Blog/markdown/游戏人工智能-Movement.assets/ezgif-7-05e9c5abac4a.gif" alt="ezgif-7-05e9c5abac4a" style="zoom: 67%;" />



<h2 id="4-群体行为"><a href="#4-群体行为" class="headerlink" title="4. 群体行为"></a>4. 群体行为</h2><ul>
<li>在群组中，通常个体的感知范围是有限的，因此每个智能体都有邻域的概念，只有在距离自己一定范围内的智能体才能感知到。这个数据可以以列表的形式存在MovingEntity中，在每一帧去更新这个列表。 </li>
<li>更进一步地，可以增加可视域的限制，智能体只能看见一定视角范围内的其他智能体，来达到更真实的模拟。 </li>
</ul>
<img data-src="/Users/luciano/Library/Mobile Documents/com~apple~CloudDocs/Blog/markdown/游戏人工智能-Movement.assets/图片7.png" alt="图片7" style="zoom:50%;" />

<h3 id="4-1-Separation（分离）"><a href="#4-1-Separation（分离）" class="headerlink" title="4.1 Separation（分离）"></a>4.1 Separation（分离）</h3><ul>
<li><strong>定义：</strong>产生一个操控力，使得智能体远离临近的智能体，且这个力的大小反比于两个智能体之间的距离。</li>
<li><strong>结合：</strong>分离可与其他个体行为结合，形成各种群体行为，如群体追逐、群体靠近、群体远离等。</li>
</ul>
<img data-src="/Users/luciano/Library/Mobile Documents/com~apple~CloudDocs/Blog/markdown/游戏人工智能-Movement.assets/图片8.png" alt="图片8" style="zoom:50%;" />

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">Separate</span>(<span class="params"><span class="keyword">this</span> MovingEntity entity, List&lt;MovingEntity&gt; teammate, <span class="keyword">float</span> desiredSeparation = <span class="number">2</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> force = Vector3.zero;</span><br><span class="line">    Vector3 dir;</span><br><span class="line">    <span class="keyword">float</span> dis;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> mv <span class="keyword">in</span> teammate)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mv == entity) <span class="keyword">continue</span>;</span><br><span class="line">        dir = entity.transform.position - mv.transform.position;</span><br><span class="line">        dis = dir.magnitude &gt; <span class="number">0.1f</span> ? dir.magnitude : <span class="number">0.1f</span>;</span><br><span class="line">        <span class="keyword">if</span> (dis &lt;= desiredSeparation)</span><br><span class="line">        &#123;</span><br><span class="line">            force += dir.normalized / dis;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> Vector3.zero;</span><br><span class="line">    <span class="keyword">return</span> force.normalized * entity.maxForce;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-2-Alignment（队列）"><a href="#4-2-Alignment（队列）" class="headerlink" title="4.2 Alignment（队列）"></a>4.2 Alignment（队列）</h3><ul>
<li><strong>定义：</strong>智能体企图与邻域中的智能体保持一致的方向。</li>
<li><strong>预期速度：</strong>邻域中所有智能体的平均速度。 </li>
<li>可用于模拟马路上汽车的运动</li>
</ul>
<img data-src="/Users/luciano/Library/Mobile Documents/com~apple~CloudDocs/Blog/markdown/游戏人工智能-Movement.assets/图片9.png" alt="图片9" style="zoom:50%;" />

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">Align</span>(<span class="params"><span class="keyword">this</span> MovingEntity entity, List&lt;MovingEntity&gt; teammate, <span class="keyword">float</span> neighborDist = <span class="number">10</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> needVelocity = Vector3.zero;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> mv <span class="keyword">in</span> teammate)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mv == entity) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> ((entity.transform.position - mv.transform.position).sqrMagnitude &lt;= neighborDist * neighborDist)</span><br><span class="line">        &#123;</span><br><span class="line">            needVelocity += mv.Velocity;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) <span class="keyword">return</span> Vector3.zero;</span><br><span class="line">    needVelocity /= count;</span><br><span class="line">    <span class="keyword">return</span> (needVelocity - entity.Velocity).normalized * entity.maxForce;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-Cohesion（聚集）"><a href="#4-3-Cohesion（聚集）" class="headerlink" title="4.3 Cohesion（聚集）"></a>4.3 Cohesion（聚集）</h3><ul>
<li><strong>定义：</strong>智能体试图朝向邻域中所有智能体的质心移动。</li>
<li><strong>实现思路：</strong>求邻域的质心并靠近（Seek）。 </li>
</ul>
<img data-src="/Users/luciano/Library/Mobile Documents/com~apple~CloudDocs/Blog/markdown/游戏人工智能-Movement.assets/图片10.png" alt="图片10" style="zoom:50%;" />

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">Cohesion</span>(<span class="params"><span class="keyword">this</span> MovingEntity entity, List&lt;MovingEntity&gt; teammate, <span class="keyword">float</span> neighborDist = <span class="number">10</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> center = Vector3.zero;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> mv <span class="keyword">in</span> teammate)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mv == entity) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> ((entity.transform.position - mv.transform.position).sqrMagnitude &lt;= neighborDist * neighborDist)</span><br><span class="line">        &#123;</span><br><span class="line">            center += mv.Velocity;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) <span class="keyword">return</span> Vector3.zero;</span><br><span class="line">    center /= count;</span><br><span class="line">    <span class="keyword">return</span> entity.Seek(center);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-4-Flocking（群集）"><a href="#4-4-Flocking（群集）" class="headerlink" title="4.4 Flocking（群集）"></a>4.4 Flocking（群集）</h3><ul>
<li><strong>鸟群算法（Boids）：</strong>Reynolds提出将分离、队列、聚集三种群体行为以一定权重组合，就能模拟各种群集的移动，如：鸟群、鱼群、羊群等。</li>
<li><strong>特点：</strong>群集不需要任何控制中心或Leader就能实现自发的移动，每个单元都是平等的，受到整体的影响，同时也会影响整体。 </li>
<li>在此基础上可以加入Wander或Seek，保证单位掉队时不会停下。</li>
<li><strong>扩展：</strong>为了达到更自然的模拟效果，可以用Perlin噪声生成权重，使分离、队列、聚集三种行为的权重随着时间变化。</li>
</ul>
<img data-src="/Users/luciano/Library/Mobile Documents/com~apple~CloudDocs/Blog/markdown/游戏人工智能-Movement.assets/æªå½å.gif" alt="æªå½å" style="zoom:150%;" />



<h2 id="5-组合操控行为"><a href="#5-组合操控行为" class="headerlink" title="5. 组合操控行为"></a>5. 组合操控行为</h2><h3 id="5-1-带优先级的加权截断总和"><a href="#5-1-带优先级的加权截断总和" class="headerlink" title="5.1 带优先级的加权截断总和"></a>5.1 带优先级的加权截断总和</h3><ul>
<li><p>每个行为都有优先级，按照优先级顺序计算操控力。</p>
</li>
<li><p>每一帧有可用操控力的概念。</p>
</li>
<li><p>计算步骤：</p>
<ul>
<li>计算优先级最高的行为的操控力。</li>
</ul>
<ul>
<li>若该操控力已将可用操控力用完，则不进行后续运算，直接执行该操控力。</li>
<li>若还有剩余的操控力，则进行下一个优先级行为的计算，计算结果按照最大操控力和剩余操控力的值两者的较小值截断。</li>
<li>以此类推直到可用操控力用完。</li>
</ul>
</li>
</ul>
<img data-src="/Users/luciano/Library/Mobile Documents/com~apple~CloudDocs/Blog/markdown/游戏人工智能-Movement.assets/图片11.png" alt="图片11" style="zoom:50%;" />

<h3 id="5-2-带优先级的抖动"><a href="#5-2-带优先级的抖动" class="headerlink" title="5.2 带优先级的抖动"></a>5.2 带优先级的抖动</h3><ul>
<li><p>每个行为都有优先级和执行概率。</p>
</li>
<li><p>计算步骤：</p>
<ul>
<li>根据优先级最高行为的执行概率计算是否需要计算该行为的操控力。</li>
<li>如果要求值而且求出的操控力不为零，则直接执行该行为，不考虑其他行为。</li>
<li>否则继续计算下一优先级的行为，以此类推。</li>
</ul>
</li>
<li><p>适用于不需要非常精确的情形。</p>
</li>
</ul>
<img data-src="/Users/luciano/Library/Mobile Documents/com~apple~CloudDocs/Blog/markdown/游戏人工智能-Movement.assets/图片12.png" alt="图片12" style="zoom:50%;" />

<h2 id="6-优化方法"><a href="#6-优化方法" class="headerlink" title="6. 优化方法"></a>6. 优化方法</h2><ul>
<li>尽量使用距离的平方。</li>
<li>若经常需要计算三角函数，可以建立正余弦查询表。</li>
<li>减少不必要的中间结果变量创建，特别是在循环中。</li>
<li>网格空间分隔<ul>
<li>问题：在群体移动行为相关的算法中，通常每个智能体都需要遍历邻域中的所有智能体，复杂度为O(N2)。</li>
<li>网格空间分隔：将空间分割为若干网格，每个网格维护一个List，储存其中的智能体。每帧开始时根据位置更新所有网格的数据。在具体行为的计算时，每个智能体能根据自己的位置确定处于哪个网格，该网格（或包含相邻网格）下的所有智能体就是自己邻域中的智能体。</li>
<li>复杂度：O(N)</li>
</ul>
</li>
</ul>
<p><strong>参考资料：</strong></p>
<ul>
<li>《游戏人工智能编程案例精粹》第3章：如何创建自治的可移动游戏智能体</li>
<li>《代码本色》第6章：自治智能体</li>
</ul>
<p><strong>Demo地址：</strong><a href="https://github.com/Luciano-0/AIMovement.git">https://github.com/Luciano-0/AIMovement.git</a></p>
]]></content>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
</search>
